---
title: 项目优化之降低DrawCall
date: 2020-10-05 10:00:33
tags: Unity
toc: true
---

一个模型的数据经过CPU传输到GPU，并命令GPU进行绘制，称为一次DrawCall。

<!--more-->

# DrawCall基本原理

Unity在准备数据并渲染游戏对象的过程是逐个游戏对象进行的，对每个游戏对象不仅GPU的渲染，重设材质与Shader操作也是非常耗时的。因此每帧的DrawCall次数是一项非常重要的系统性能指标。

# 降低DrawCall的基本原理

DrawCall是CPU调用底层图形接口、绘制游戏对象的过程。对于GPU来说，一个游戏对象与大量游戏对象，其图形处理的工作量是一样的。

对DrawCall的优化，主要是为尽量减少CPU在调用图形接口上的开销而努力。每个游戏对象尽量减少渲染次数，多个游戏对象尽量一起渲染。

# 降低DrawCall的主要途径（10个）

一般项目中的角色和场景这两个最消耗资源，其中角色是CPU的瓶颈，场景是GPU的瓶颈。因此降低DrawCall的总体思路是对美术资源进行梳理，使用大量合并DrawCall，人物角色减少材质与纹理的依赖和简化多余特效等方法。允许玩家在低端设备上选择关闭某些功能与特效来换取更流畅的帧速率与性能。

## DrawCall批处理技术（DrawCall Batching）

把多个游戏对象打包，然后再一个DrawCall渲染他们。

批处理核心：在可见性测试之后，检查所有要绘制的对象材质，把相同材质分为一组。然后把他们组合成一个对象，这样就可以在一个DrawCall中作为一个对象处理。

Unity提供了动态批处理（Dynamic Batching）和静态批处理（Static Batching）两种方式。

动态批处理完全自动进行，不需要也无法进行任何干预，对于顶点数在900以内的可移动物体，只要使用相同的材质，就会组成批处理。

静态批处理需要把游戏中永远不会移动、旋转、缩放的物体标记为静态（复选框勾选），然后无论大小，都会组成批处理。

## 使用图集（Texture Packing或者Texture Atlasing），减少材质的使用

首先尽量减少场景中使用的材质数量，即共享材质或复用材质，对于仅纹理不同的材质可以把纹理组合到一张更大的纹理中（称为“图集”）,然后把不会移动的物体标记为Static。

因为Unity在判断哪些游戏对象进行批处理，一般是根据这些对象是否具有共同的材质和贴图。

## 尽量少用反光与阴影

因为这两项会使物体多次渲染

## 视锥体合理裁剪（Frustum Culling）

视锥体合理裁剪使Unity的内置功能，我们要做的是寻求一个合适的远裁剪平面。一般是对大型场景中的大量游戏对象进行合理分层（Layer），对于大型建筑物，则使用较大的裁剪距离，对于小游戏对象，可以使用较小的裁剪距离。场景中的粒子系统可以使用更小的裁剪距离。

## 遮挡剔除方法（Occlussion Culling）



## 网格渲染器（Mesh Renderer）的控制

当处于摄像机视锥体内，并添加了网格渲染器组件的对象才会产生渲染的开销，而空的游戏对象并不会产生渲染开销。根据这个原理，我们可以把暂时无需显示的游戏对象使用脚本的方式控制不进行渲染，需要的时候再渲染。

## 减小游戏对象的缩放

分别拥有缩放大小（1，1，1）和（2，2，2）的两个对象将不会进行批处理，统一缩放的对象不会与非统一缩放的对象进行批处理。

## 减少多通道Shader的使用

多通道的Shader会妨碍批处理操作。比如，几乎Unity中所有的着色器再前向渲染（Foreward Rendering）中都支持多个光源。因此为它们开辟多个通道，所以对批处理有影响。

## 脚本访问材质方法

如果需要通过脚本来访问复用材质属性，那么如果使用Renderer.material来改变贴图将会造成一份材质属性的更改。因此一般应该使用Render.sharedMaterial来保证材质的共享状态。

## 尽量多使用预制体（Prefab）

使用预设生成的对象会自动使用相同的网格模型和材质，因此会自动被批处理。对于复杂的静态场景，还可以考虑自行设计lo遮挡剔除算法，尽量减少可见游戏对象数量的同时也可以减少DrawCall。

