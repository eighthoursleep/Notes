# 代码设计的7大原则

- 单一职责原则
- 开闭原则
- 接口隔离原则
- 依赖倒置原则
- 里氏替换原则
- 迪米特法则
- 组合复用原则



## 单一职责原则

> 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。
> 单一职责原则是实现高内聚、低耦合的指导方针，是最简单却最难运用的原则，需要设计人员发现类的不同职责并将其分离。

单一职责原则（SRP）：**就一个类而言，应该仅有一个引起它变化的原因。**

单一职责原则要求一个接口或类只有一个原因引起变化，也就是**一个接口或类只有一个职责，它就负责一 件事情。**

单一职责原则有什么**好处**：

1. 类的复杂性降低，实现什么职责都有清晰明确的定义；
2. 可读性提高，复杂性降低，那当然可读性提高了；
3. 可维护性提高，可读性提高，那当然更容易维护了；
4. 变更引起的风险降低。

**注意：**单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是**“职责”和“变化原因”都是不可度量的，因项目而异**，因环境而异。

对于接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑了。 生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责 也会人为地增加系统的复杂性。本来一个类可以实现的行为硬要拆成两个类，然后再使用聚 合或组合的方式耦合在一起，人为制造了系统的复杂性。所以原则是死的，人是活的。

单一职责原则很难在项目中得到体现，非常难，为什么？在国内，技术人员的地位和话 语权都比较低，因此在项目中需要考虑环境，考虑工作量，考虑人员的技术水平，考虑硬件 的资源情况，等等，最终妥协的结果是经常违背单一职责原则。

单一职责适用于接口、类，同时也适用于方法，什么意思呢？一个方法尽可能做一件事情，比如一个方法修改用户密码，不要把这个方法放到“修改用户信息”方法中，这个方法的颗粒度很粗

## 里氏替换原则

> 所有引用基类的地方必须能透明地使用其子类的对象。
> 里氏替换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。
> 在运用里氏替换原则时，应该将父类设计为抽象类或者接口，让子类继承父类或实现父类接口，并实现在父类中声明的方法。

里氏替换原则（LSP）：**所有引用基类的地方必须能透明地使用其子类的对象。**

只要父类能出现的地方子类就可以出现，而且 替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。

但是，反过来就不行了，有子类出现的地方，父类未必就能适应。

里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义:

1. 子类必须完全实现父类的方法。

   **注意：**在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明 类的设计已经违背了里氏替换原则。

   **注意：**如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发 生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。

2. 子类可以有自己的个性。

3. 覆盖或实现父类的方法时，输入参数可以被放大。

4. 覆写或实现父类的方法时，输出结果可以被缩小。

采用里氏替换原则的目的就是**增强程序的健壮性，版本升级时也可以保持非常好的兼容性。**即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务 含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑。

在项目中，采用里氏替换原则时，**尽量避免子类的“个性”**。一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀——委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替 换的标准。

## 依赖倒置原则

> 高层模块不应该依赖底层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。
> 依赖倒转原则要求：要针对接口编程，不要针对实现编程。

依赖倒置原则（DIP）：（3层含义）

1. 高层模块不应该依赖低层模块，两者都应该依赖其抽象；
2. 抽象不应该依赖细节；
3. 细节应该依赖抽象。

在编程中的表现：

1. 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系时通过接口或抽象类产生；
2. 接口或抽象类不依赖实现类；
3. 实现类依赖接口或抽象类。

更精简的定义，依赖倒置原则的**核心**：“**面向接口编程**”——OOP的精髓之一。

**本质：**

通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。

需要**遵循以下规则**：

1. **每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备。**（依赖倒置基本要求）

2. **变量的表面类型尽量使接口或者抽象类。**（例外：工具类一般不需要接口或抽象类，类的clone也必须使实现类(JDK的规范)）

3. **任何类都不应该从具体类派生。**

   （并非绝对，实际中，有时设计缺陷在所难免，不超过两层的继承都可以接受。还有负责维护项目的基本可以不考虑这个规则，因为修复行为通过一个继承关系，覆写一个方法就可以修正很大的bug）

4. **尽量不要覆写基类的方法。**

   （如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定影响。）

5. **结合里氏替换原则使用。**

   （接口负责定义`public`属性和方法，并声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。）

**作用：**

可以减少类之间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。

**依赖正置**就是类间的依赖是实实在在的实现类间的依赖，也就是**面向实现编程**。

**例子：**

```c#
//Program.cs
using System;

namespace DesignPatternsDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            IDriver zhangSan = new Person();
            ICar bmw = new BMW();
            zhangSan.Drive(bmw);
        }
    }
}
```

```c#
//ICar.cs
interface ICar
{
    public void Run();
}
```

```c#
//IDriver.cs
interface IDriver
{
    public void Drive(ICar car);
}
```

```c#
//Person.cs
class Person : IDriver
{
    public void Drive(ICar car)
    {
        car.Run();
    }
}
```

```c#
//BMW.cs
using System;

class BMW : ICar
{
    private string name = "";
    public BMW(string name="BMW")
    {
        this.name = name;
    }
    public void Run()
    {
        Console.WriteLine(this.name + " is Runing.");
    }
}
```

在新增加低层模块时，只修改了业务场景类，也就是高层模块，对其他低层模块如`Driver`类不需要做任何修改，业务就可以运行，把“变更”引起的风险扩散降到最低。

依赖倒置**对并行开发的影响**：

**两个类之间有依赖关系，只要制定出两者之间的接口（或抽象类）**就可以独立开发了，而且项目之间的单元测试也可以独立地运行，而TDD（Test-Driven Development，测试驱动开发）开发模式就是依赖倒置原则的最高级应用。

我们只需要一个`ICar`的接口，就可以对`Driver`类进行单元测试。

这属于测试驱动开发的精髓：

两个相互依赖的对象可以分别进行开发，孤立地进行单元测试，进而保证并行开发的效率和质量。先写好单元测试类，然后再写实现类。

**抽象是对实现的约束**，对依赖者而言，也是一种契约，**不仅仅约束自己，还同时约束自己与外部的关系**，其目的是**保证所有的细节不脱离契约的范畴**，确保约束双方按照既定的契约（抽象）共同发展，只要抽象这根基线在，细节就脱离不了这个圈圈，始终让你的对象做 到“言必信，行必果”。

**对象的依赖关系有3种方式来传递**：

1. **构造函数传递依赖对象**

   ```c#
   interface IDriver
   {
       public void Drive();
   }
   class Diver : IDriver
   {
       private ICar car;
       //构造函数注入
       public Driver(ICar car)
       {
           this.car = car;
       }
       public void Drive()
       {
           this.car.Run();
       }
   }
   ```

2. **Setter方法传递依赖对象**

   ```c#
   interface IDriver
   {
       public void SetCar(ICar car);
       public void Drive();
   }
   class Diver : IDriver
   {
       private ICar car;
   
       public void SetCar(ICar car)
       {
           this.car = car;
       }
       public void Drive()
       {
           this.car.Run();
       }
   }
   ```

3. 接口声明依赖对象，也叫接口注入

   ```c#
   interface ICar
   {
       public void Run();
   }
   
   interface IDriver
   {
       public void Drive(ICar car);
   }
   
   class Diver : IDriver
   {
       public void Drive(ICar car)
       {
           car.Run();
       }
   }
   ```

   

## 接口隔离原则

> 客户端不应该依赖那些它不需要的接口。
> 在使用接口隔离原则的时候，需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来不方便。

接口分2种：

- 实例接口
- 类接口

**什么是隔离？**（2种定义）

1. 客户端不应该依赖它不需要的接口。
2. 类之间的依赖关系应该建立在最小的接口上。

**定义概括**：**接口尽量细化，同时接口中的方法尽量少。**

**与单一职责原则有什么不同？**

审视角度不同，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。

例如，一个接口的职责可能包含10个方法，这10个方法都放在一个接口中，并且提供给多个模块访问。各个模块按照规定的权限来访问，在系统外通过文档约束“不使用的方法不要访问”，按照单一职责原则是允许的，按照接口隔离原则是不允许的。因为它要求“**尽量使用多个专门的接口**”。专门的接口指什么？就是指提供给每个模块的都应该是单一接口，**提供给几个模块就应该有几个接口**，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问。

接口隔离原则是对接口进行规范约束，其包含以下4层含义：

1. **接口要尽量小。**

   （接口隔离原则的核心，不出现臃肿的接口，但“小”要有限度，首先**不能违反单一职责原则**，不能无限拆把业务逻辑拆了）

2. **接口要高内聚。**

   （什么是高内聚？高内聚就是提高接口、类、模块的处理能力，减少对外的交互。要求在接口中**尽量少公布public方法**，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越 少，同时也有利于降低成本。）

3. **定制服务。**

   （一个系统或系统内的模块之间必然会有耦合，有耦合就要有相互访问的接口（并不一定就是`Interface`，也可能是一个类或单纯的数据交换），我们设计时就需要为各个访问者（即客户端）定制服务，什么是定制服务？定制服务就是**单独为一个个体提供优良的服务**。我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务。采用定制服务就必然有一个要求：**只提供访问者需要的方法**）

4. **接口设计是有限度的。**

   （接口的设计粒度越小，系统越灵活，这是不争的事实。但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低，这不是一个项目或产品所期望看到的，所以接口设计一定要注意适度，这个“度”如何来判断呢？根据经验和常识判断，没有一个固化或可测量的标准。）

接口隔离原则是对接口的定义，同时也是对类的定义，**接口和类尽量使用原子接口或原子类来组装。**

**原子划分规则：**

1. **一个接口只服务于一个子模块**或业务逻辑；
2. 通过业务逻辑**压缩接口中的public方法，接口时常去回顾**，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法；
3. 已经**被污染了的接口，尽量去修改**，若变更的**风险较大，则采用适配器模式**进行转化处理；
4. **了解环境，拒绝盲从。**每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设计就出自你的手中



## 迪米特法则

> 每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。

迪米特法则（Law of Demeter，LoD）也称为**最少知识原则**（Least Knowledge Principle，LKP）

一个对象应该对其他对象有最少的了解。

**一个类应该对自己需要耦合或调用的类知道得最少。**

被调用的类的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。

迪米特法则对类的**低耦合**提出了明确的要求，其包含以下4层含义：

1. **只和朋友交流。**

   （每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等。）

   （一个类只和朋友交流，不与陌生类交流，不要出现`getA().getB().getC().getD()`这种 情况（在一种极端的情况下允许出现这种访问，即每一个点号后面的返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象，当然，API提供的类除外。）

2. **朋友间也是有距离的。**

   （迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限。）

3. **是自己的就是自己的**

   （一个方法放在本类中也可以，放在其他类中也没有错， 那怎么去衡量呢？原则：如果一个方法放在本类中，既不增加类间关系，也对本类没有负面影响，那就放置在本类中。）

4. **谨慎使用Serializable**

迪米特法则的**核心观念**就是**类间解耦，弱耦合**。只有弱耦合了以后，类的复用率才可以提高。其要求的结果就是产生了大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度。在采用迪米特法则时需要反复权衡，既做到让结构清晰，又做到高内聚低耦合。

如果一个类跳转两次以上才能访问到另一个类，就需要想办法进行重构了，为什么是两次以上呢？因为一个系统的成功不仅仅是一个标准或是原则 就能够决定的，有非常多的外在因素决定，跳转次数越多，系统越复杂，维护就越困难，所以只要跳转不超过两次都是可以忍受的，这需要具体问题具体分析。

迪米特法则要求类间解耦，但解耦是有限度的，除非是计算机的最小单元——二进制的0和1。那才是完全解耦，在实际的项目中，需要适度地考虑这个原则，别为了套用原则而做 项目。



## 开闭原则

> 软件实体应当对扩展开放，对修改关闭。
> 指软件实体应尽量在不修改原有代码的情况下进行扩展。

**定义：**一个软件实体如**类**、**模块**和**函数**应该**对扩展开放，对修改关闭。**

**含义：**一个软件实体（模块、抽象、类、方法）应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。

**注意**：开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。

可以把变化归纳为以下三种类型：

1. 逻辑变化

   （只变化一个逻辑，而不涉及其他模块，比如原有的一个算法是a\*b+c，现在需要修改为 a\*b\*c，可以通过修改原有类中的方法的方式来完成，前提条件是所有依赖或关联类都按照相同的逻辑处理。）

2. 子模块变化

   （一个模块变化，会对其他的模块产生影响，特别是一个低层次的模块变化必然引起高层模块的变化，因此在通过扩展完成变化时，高层次的模块修改是必然的。）

3. 可见视图变化

一个项目的基本路径应该是这样的：项目开发、重构、测试、投产、运维，其中的重构可以对原有的设计和代码进行修改， 运维尽量减少对原有代码的修改，保持历史代码的纯洁性，提高系统的稳定性。

**为什么要采用开闭原则？**

1. **开闭原则对测试的影响**

   所有已经投产的代码都是有意义的，并且都受系统规则的约束，这样的代码都要经 过“千锤百炼”的测试过程，不仅保证逻辑是正确的，还要保证苛刻条件下不产生“有毒代码”（Poisonous Code），因此有变化提出时，我们就需要考虑一下， 原有的健壮代码是否可以不修改，仅仅通过扩展实现变化呢？否则，就需要把原有的测试过 程回笼一遍，需要进行单元测试、功能测试、集成测试甚至是验收测试，现在虽然在大力提 倡自动化测试工具，但是仍然代替不了人工的测试工作。

   一个方法的测试方法一般不少于3种，为什么呢？首先是正常的业务逻辑要保证测试到，其次是 边界条件要测试到，然后是异常要测试到，比较重要的方法的测试方法甚至有十多种，而且 单元测试是对类的测试，类中的方法耦合是允许的，在这样的条件下，如果再想着通过修改 一个方法或多个方法代码来完成变化，基本上就是痴人说梦，该类的所有测试方法都要重构。

2. **开闭原则可以提高复用性。**

   在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立 实现一个业务逻辑。只有这样代码才可以复用，粒度越小，被复用的可能性就越大。那为什 么要复用呢？减少代码量，避免相同的逻辑分散在多个角落，避免日后的维护人员为了修改 一个微小的缺陷或增加新功能而要在整个项目中到处查找相关的代码，然后发出对开发人 员“极度失望”的感慨。那怎么才能提高复用率呢？缩小逻辑粒度，直到一个逻辑不可再拆分为止。

3. **开闭原则可以提高可维护性。**

   一款软件投产后，维护人员的工作不仅仅是对数据进行维护，还可能要对程序进行扩 展，维护人员最乐意做的事情就是扩展一个类，而不是修改一个类，甭管原有的代码写得多 么优秀还是多么糟糕，让维护人员读懂原有的代码，然后再修改，是一件很痛苦的事情，不 要让他在原有的代码海洋里游弋完毕后再修改，那是对维护人员的一种折磨和摧残。

4. **面向对象开发的要求。**

   万物皆对象，我们需要把所有的事物都抽象成对象，然后针对对象进行操作，但是万物 皆运动，有运动就有变化，有变化就要有策略去应对，怎么快速应对呢？这就需要在设计之 初考虑到所有可能变化的因素，然后留下接口，等待“可能”转变为“现实”。

**如何使用开闭原则？**

1. 抽象约束。

   抽象是对一组事物的通用描述，没有具体的实现。这也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：

   1. 通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；
   2. 参数类型、引用对象尽量使用接口或者抽象类，而不是实现类；
   3. 抽象层尽量保持稳定，一旦确定即不允许修改。

2. 元数据控制模块行为。

   尽量使用元数据来控 制程序的行为，减少重复开发。什么是元数据？用来描述环境和数据的数据，通俗地说就是 配置参数，参数可以从文件中获得，也可以从数据库中获得。

3. 制定项目章程。

   在一个团队中，建立项目章程是非常重要的，因为章程中指定了所有人员都必须遵守的 约定，对项目来说，约定优于配置。一旦项目成员都熟悉规则，比通过接口或抽象类进行约束效率更高，而且扩展性一点也没有减少。

4. 封装变化。

   1. 将相同的变化封装到一个接口或抽象类中；
   2. 将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。

   封装变化，也就是受保护的变化，找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口，准确地讲是封装可能发生的变化，一旦预测到或“第六感”发觉有变化，就可以进行封装，23个设计模式都是从各个不同的角度对变化进行封装的。

## 合成复用原则 

> 优先使用对象组合，而不是继承来达到复用的目的。
> 一般而言，如果两个类之间是"Has-A"关系应使用组合或聚合，如果是"Is-A"关系可使用继承。

**定义**

合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要**尽量先使用组合或者聚合等关联关系**来实现，**其次才考虑使用继承关系**来实现。

如果要**使用继承关系，则必须严格遵循里氏替换原则**。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。

**重要性**

通常**类的复用**分为**继承复用**和**合成复用**两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。

1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。


采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。

1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
2. 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。

**实现方法**

合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。