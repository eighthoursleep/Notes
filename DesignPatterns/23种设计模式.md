# 23种设计模式

[TOC]

## 创建型模式（5种）

### 单例模式

**定义：**确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

**怎么实现？**

对象产生是通过new关键字完成的（当然也有其他方式，比如对象复制、反射等），这个怎么控制呀，在使用 new关键字创建对象时，都会根据输入的参数调用相应的构造函数，如果我们把构造函数设置为private私有访问权限就可以禁止外部创建对象。

```c#
using System;

namespace DesignPatternsDemo
{
    public class Emperor
    {
        private static Emperor instance;
        public static Emperor Instance
        {
            get
            {
                if (instance == null)//懒汉式单例
                {
                    instance = new Emperor();
                }
                return instance;
            }
        }
        private Emperor(){ }
    }
}
```

**优点：**

1. 减少了内存开支，特别是一个对象需要频繁创建、销毁时，而且创建或销毁时性能又无法优化，这时单例模式的优势就非常明显。
2. 以减少了系统的性能开销，当一个对象的产生需要 比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一 个单例对象，然后用永久驻留内存的方式来解决。
3. 避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。
4.  单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单 例类，负责所有数据表的映射处理。

**缺点：**

1. **单例模式一般没有接口，扩展很困难**，若要扩展，除了修改代码基本上没有第二种途径可以实现。单例模式为什么不能增加接口呢？因为接口对单例模式是没有任何意义的，它要求“自行实例化”，并且提供单一实例、接口或抽象类是不可能被实例化的。当然，在特殊情况下，单例模式可以实现接口、被继承等，需要在系统开发中根据环境判断。
2. 单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的。
3. 单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中。

**使用场景：**

在一个系统中，要求一个类有且仅有一个对象，如果出现多个对象就会出现“不良反应”，可以采用单例模式：

1. 要求生成唯一序列号的环境。
2. 在整个项目中需要一个共享访问点或共享数据。
3. 创建一个对象需要消耗的资源过多，如要访问I/O和数据库等资源。
4. 需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式（当然，也可以直接声明为static的方式）。

**注意事项：**

1. **在高并发情况下，请注意单例模式的线程同步问题。**

   （单例模式在低并发的情况下尚不会出现问题，若系统压力增大，并发量增加时则可能在内存中出现多个实例，破坏了最初的预期。为什么会出现这种情况呢？如一个线程A执行到`singleton = new Singleton()`，但还没有获得对象（对象初始化是需要时间的），第二个线程 B也在执行，执行到`if(singleton == null)`判断，那么线程B获得判断条件也是为真，于是继续运行下去，线程A获得了一个对象，线程B也获得了一个对象，在内存中就出现两个对象！

   解决线程不安全的方法很有多，可以在getSingleton方法前加`synchronized`关键字，也可以 在getSingleton方法内增加synchronized来实现，但都不是最优秀的单例模式。

   建议是使用“饿汉式单例”：

   ```c#
   using System;
   
   namespace DesignPatternsDemo
   {
       public class Emperor
       {
           private static Emperor instance = new Emperor();//饿汉式单例
           public static Emperor Instance
           {
               get => instance;
           }
           private Emperor(){ }
       }
   }
   ```

   简单来说：饿汉式是在用时间换空间，因为一上来就实例化一个对象，不管你用还是不用，占用了内存，但实例化也会耗时间。懒汉式是在用空间换时间，用到了再实例化。）

2. **需要考虑对象的复制情况。**

   （对象默认是不可以被复制的，若实现了Cloneable接口，并实现了clone方法，则可以直接通过对象复制方式创建一个新对象，对象 复制是不用调用类的构造函数，因此即使是私有的构造函数，对象仍然可以被复制。在一般 情况下，类复制的情况不需要考虑，很少会出现一个单例类会主动要求被复制的情况，解决 该问题的最好方法就是单例类不要实现Cloneable接口。）

 **单例模式的扩展：**

如果要求一个类只能产生两三个对象，该怎么实现？

```c#
using System;
using System.Collections.Generic;

namespace DesignPatternsDemo
{
    public class King
    {
        private static int KingNum = 2;//实例的数量
        private static List<King> kings = new List<King>();//实例列表
        private static Random RandomInst = new Random(); 
        
        public string Name;
        
        static King()
        {
            for (int i = 0; i < KingNum; i++)
            {
                kings.Add(new King(i.ToString()));
            }
        }
        public static King Instance
        {
            get
            {
                int rand = RandomInst.Next(0, KingNum);
                return kings[rand];
            }
        }
        private King(string Name)
        {
            this.Name = Name;
        }
        public void saySomething()
        {
            Console.WriteLine(this.Name + " is a King.");
        }
    }
}
```

需要产生固定数量对象的模式就叫做**有上限的多例模式**。

我们可以在设计时决定在内存中有多少个实例，方便系统进行 扩展，修正单例可能存在的性能问题，提供系统的响应速度。例如读取文件，我们可以在系 统启动时完成初始化工作，在内存中启动固定数量的reader实例，然后在需要读取文件时就 可以快速响应。



### 抽象工厂模式



### 建造者模式



### 工厂方法模式



### 原型模式





## 结构型模式（7种）



### 适配器模式



### 桥接模式



### 装饰器模式



### 代理模式



### 外观模式



### 组合模式



### 享元模式



## 行为型模式（11种

## ）



### 策略模式



### 模板方法模式



### 观察者模式



### 迭代器模式



### 责任链模式



### 命令模式



### 备忘录模式



### 状态模式



### 访问者模式



### 中介者模式



### 解释器模式

