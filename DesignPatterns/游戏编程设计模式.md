# 游戏编程设计模式



## 常用设计模式（6种）



### 命令模式

命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象，同时支持可撤消的操作。

**要点**

1. 将一组行为抽象为对象，这个对象和其他对象一样可以被存储和传递，从而实现行为请求者与行为实现者之间的松耦合，这就是命令模式。
2. 命令模式是回调机制的面向对象版本。
3. 命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。
4. 命令模式的优点有：对类间解耦、可扩展性强、易于命令的组合维护、易于与其他模式结合，而缺点是会导致类的膨胀。
5. 命令模式有不少的细分种类，实际使用时应根据当前所需来找到合适的设计方式。

**使用场合**

1. 命令模式很适合实现诸如撤消，重做，回放，时间倒流之类的功能。
2. 基于命令模式实现录像与回放等功能，也就是执行并解析一系列经过预录制的序列化后的各玩家操作的有序命令集合。

**引申与参考**

最终我们可能会得到很多不同的命令类。为了更容易实现这些类，定义一个具体的基类，包含一些能定义行为的高层方法，往往会有帮助。可以将命令的主体execute()转到子类沙箱中。

对象可以响应命令，或者将命令交给它的从属对象。如果我们这样实现了，就完成了一个职责链模式。

对于等价的实例，可以用享元模式提高内存利用率。



### 享元模式



### 观察者模式



### 原型模式



### 单例模式



### 状态模式



## 序列型模式（3种）



### 双缓冲模式



### 游戏循环模式



### 更新方法



## 行为型模式（3种）



### 字节码模式



### 子类沙盒模式



### 类型对象模式



## 分离型模式（3种）



### 组件模式



### 事件队列



### 服务定位器模式



## 优化型模式（4种）



### 数据局部性



### 脏标识模式



### 对象池模式

**放弃单独地分配和释放对象，从固定的池中重用对象，以提高性能和内存使用率。**

游戏中，一个法杖在发射数百个粒子时，我们希望这些粒子生成的快一点别卡了。而且更重要的是要保证生成和销毁这些粒子的过程不要出现内存碎片。

**内存碎片**是指，在堆中的空余空间被碎成了很多小的内存碎片，而不是大的连续内存块。 总共的 可用内存也许很大，但是最长的连续空间可能难以忍受地小。假设我们有十四个空余字节，但是被一块正在使用的内存分割成了两个七字节的碎片。 而我们尝试分配十二字节的对象，那么就会失败。即使在理论上有足够的可用内存，内存也会分配失败。

哪怕碎片发生得不频繁，它也仍会逐渐把堆变成有空洞和裂隙的不可用泡沫，最终完全无法运行游戏。

由于碎片化和可能很慢的内存分配，游戏中何时何处管理内存通常需要十分小心。 一个简单又有效的办法是——游戏开始时取一大块内存，然后直到游戏结束才去释放它。 但是这对要在游戏运行时创建和销毁事物的系统来说是痛苦的。

使用对象池， 对内存管理器，我们只需要将一大块内存分出来，保持在游戏运行时不释放它。 对于池的使用者，我们可以简单地构造析构我们想要的内容对象。

**对象池模式的要点**

- 定义一个包含了一组可重用对象的对象池。其中每个可重用对象都支持查询“使用中”状态，说明它是不是“正在使用”。 对象池被初始化时，就创建了整个对象集合（通常使用一次连续的分配），然后初始化所有对象到“不在使用中”状态。
- 当我们需要新对象时，就从对象池中获取。从对象池取到一个可用对象，初始化为“使用中”然后返回给我们。当不再需要某对象时，将其设置回“不在使用中”状态。 通过这种方式，便可以轻易地创建和销毁对象，而不必每次都分配内存或其他资源。

**使用场合**
这个模式广泛使用在可见事物上，比如**游戏物体**和**特效**。但是它也可在不那么视觉化的数据结构上使用，比如**正在播放的声音**。
满足以下情况可以使用对象池：

- **需要频繁创建和销毁对象。**

- **对象大小相仿。**

- **在堆上分配对象缓慢**或者**会导致内存碎片。**

- **每个对象都封装了像数据库或者网络连接这样很昂贵又可以重用的资源。**

**注意事项：**

你通常依赖垃圾回收机制或者`new`和`delete`来处理内存管理。 通过使用对象池，意味着处理内存的责任落到了你头上。

**池可能在不需要的对象上浪费内存**

对象池的大小需要根据游戏的需求设置。 当池子太小时，很明显需要调整。 但是也要小心确保池子没有太*大*。更小的池子提供了空余的内存做其他有趣的事情。

**同时只能激活固定数量的对象**

在某种程度上这是好事。 将内存按不同的对象类型划分单独的池保证了这点。 尽管如此，这也意味着试图从池子重用对象可能会失败，因为它们都在使用中。但有以下对策：

- 完全阻止这点，保证这不发生。
- 就不要创建对象了。
- 强制干掉一个已有的对象。
- 增加池的大小。

**每个对象的内存大小是固定的**

如果你想要在同一个对象池中存储不同类型的对象，或者存储子类的实例， 你需要保证池中的每个位置对*最大的*可能对象都有足够的内存。 否则，超过预期大小的对象会占据下一个对象的内存空间，导致内存崩坏。

同时，如果对象大小是变化的，你是在浪费内存。 每个槽都需要能存储最大的对象。 如果对象很少那么大，每放进去一个小对象都是在浪费内存。像是通过机场安检时，使用最大允许尺寸的箱子，而里面只放了钥匙和钱包。

当你发现自己在用这种方式浪费内存，考虑将池根据对象的大小分割为分离的池 ——大箱子给大行李，小箱子给口袋里的东西。

**重用对象不会自动清除。**

由于对象池重用对象不再经过内存管理系统，我们失去了这层安全网。 更糟的是，为“新”对象使用的内存之前存储的是同样类型的对象。 这使你很难分辨出创建新对象时的未初始化问题： 那个存储新对象的内存已经保存了来自于上个生命周期中的*几乎完全*正确的数据。

由于这点，特别注意在池里初始化对象的代码，保证它*完全*地初始化了对象。 甚至很值得加个在对象回收时清空对象槽的debug选项。

**未使用的对象会保留在内存中**

如果你使用有垃圾回收的对象池系统，注意潜在的冲突。 由于池不会在对象不再使用时真正地析构它们，如果对象仍然保留任何对*其他*对象的引用，也会阻止垃圾回收器回收它。 为了避免这点，当池中对象不再使用，清除它对其他对象的所有引用。



**对象池模式与享元模式**

对象池模式与享元模式类似。 两者都控制了一系列可重复使用的对象。不同在于重复使用的含义。

享元对象分享实例间同时拥有的相同部分。

享元模式在不同上下文中使用相同对象避免了重复内存使用。

对象池中的对象也被重复使用了，但是是在不同的时间点上被重用的。重复使用在对象池中意味着对象在原先的对象用完之后再分配内存。对象池的对象不会在它的生命周期中与其他对象共享数据。

将内存中同样类型的对象进行整合，能确保在遍历对象时CPU缓存是满载的。



### 空间分区模式



