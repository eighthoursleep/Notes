# C#托管堆和垃圾回收

本文讨论：
1. 托管应用程序如何构造新对象
2. 托管堆如何控制这些对象的生存期
3. 如何回收这些对象的内存
4. CLR中的垃圾回收器如何工作
5. 相关性能问题
6. 如何设计应用程序来最有效地使用内存

[TOC]

## 托管堆基础

在面向对象的环境中，每个类型都代表可供程序使用的一种资源。要使用这些资源，必须为代表资源的类型分配内存。

访问一个资源所需步骤：
1. 调用IL命令newobj,为代表资源的类型分配内存（一般使用C# `new`操作符）。
2. 初始化内存，设置资源的初始状态并使资源可用。类型的实例构造器负责设置初始状态。
3. 访问类型的成员来使用资源。
4. 摧毁资源的状态以进行清理。
5. 释放内存。垃圾回收器独自负责这一步。

### 从托管堆分配资源

CLR要求所有对象都从托管堆分配。

进程初始化时，CLR划出一个地址空间区域作为托管堆。

CLR还要维护一个指针，NewObjPtr。该指针指向下一个对象在堆中的分配位置。刚开始时，NextObjPtr设为地址空间区域的基地址。

C#的new操作符导致CLR执行以下步骤：
1. 计算类型的字段以及从基类继承的字段所需的字节数
2. 加上对象的开销所需的字节数。
   1. 每个对象都有两个开销字段：类型对象指针、同步块索引。
   2. 用于32位应用程序，这两个字段各自需要32位，每个对象增加8字节。对于64位应用程序，这两个字段各自需要64位，每个对象要增加16字节。
3. CLR检查区域中是否有分配对象所需的字节数。如果托管堆有足够的可用空间，就在NextObjPtr指针指向的指针放入对象，为对象分配的字节会被清零。


### 垃圾回收算法

### 垃圾回收和调试

## 提升性能

### 垃圾回收触发条件

### 大对象

### 强制垃圾回收

### 监听应用程序的内存使用

## 使用需要特殊清理的类型

### 使用包装了本机资源的类型

### 一个有趣的依赖性问题

### GC为本机资源提供的其他功能

### 终结的内部工作原理

### 手动监视和控制对象的生存期