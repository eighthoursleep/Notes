# C#数组

数组是允许将多个数据项作为集合来处理的机制。

CLR支持一维、多维和交错数组。

所有数组类型都隐式从System.Array抽象类派生，后者又派生自Sytem.Object。

因此数组始终是引用类型，在托管堆上分配的。在应用程序的变量或字段中，包含的是对数组的引用，而非包含数组本身的元素。

例子：
```c#
Int32[] nums; //声明一个包含Int32值的一维数组，因为还没有分配数组，nums的值未null
nums = new Int32[100]; //分配含有100个Int32值的数组，所有Int32都被初始化为0。
//由于数组是引用类型，所以在托管堆上会分配容纳100个未装箱Int32所需的内存块。
//实际上，除了数组元素，数组对象占据的内存块还包含一个类型对象指针、一个同步块索引、一些额外成员。该数组的内存块地址被返回保存到nums变量中。
```
[TOC]

为了符合“公共语言规范”(CLS)，所有数组都必须是0基数组（最小索引为0）。
虽然如此，CLR也支持非0基数组，只是不提倡使用。会又少许性能下降。

每个数组都关联一些额外的开销信息，包括数组的秩、数组每一维的下限（几乎总是0）和每一维的长度、数组的元素类型。

CLR还支持交错数组，即数组构成的数组。0基一维交错数组的性能和普通一维数组一样好。不过，访问交错数组的元素意味着必须进行两次或更多次数组访问。

例子：
```c#
Point[][] polygons = new Point[3][];

polygons[0] = new Point[10];
polygons[1] = new Point[20];
polygons[2] = new Point[30];

for(Int32 x=0; x< polygons[0].Length;x++)
{
    Console.WriteLine(polygons[0][x]);
}

```

**注意**，CLR会验证数组索引的有效性。不能访问创建范围外的索引的元素，这样做会抛异常。

允许访问数组范围之外的内存会破坏类型安全性，而且会造成潜在的安全漏洞，所以CLR不允许可验证的代码这么做。

## 一、初始化数组元素

## 二、数组转型

## 三、所有数组都隐式派生自System.Array

## 四、所有数组都隐式实现IEnumerable,ICollection和IList

## 五、数组的传递和返回

## 六、创建下限非零的数组

## 七、数组的内部工作原理

## 八、不安全的数组访问和固定大小的数组