# C# 类型基础

- 所有的类型都从System.Object派生
- 类型转换
- 命名空间、程序集
- 运行时的相互关系

本文要讨论：
1. C#所有类型都具有的一组基本行为。
2. 类型安全性、命名空间、程序集。
3. 如何将对象从一种类型转换成另一种类型。
4. 类型、对象、线程栈和托管堆在运行时的相互关系

## 一、所有类型都从System.Object派生

“运行时”要求每个类型最终都从System.Object类型派生。

```C#
class Employee { //隐式派生自Object

}
class Employee : System.Object { //显式派生自Object

}
```

正因如此，每个类型的每个对象都保证有一组最基本的方法。

System.Object的公共实例方法：
|公共方法  | 说明 |
| - | - |
| Equals | 如果两个对象具有相同的值，返回true。 |
| GetHashCode | 返回对象的值的哈希码。 |
| ToString | 默认返回类型的完整名称。（this.GetType().FullName） |
| GetType | 返回从Type派生的一个类型的实例，指出调用GetType的那个对象是什么类型。GetType是非虚方法，目的是防止类重写该方法，隐瞒类型，进而破坏类型安全。 |

| 受保护方法 | 说明 |
| - | - |
| MemberwiseClone | 非虚方法，创建类型的实例，并将新的对象的实例字段设为与this对象的实例字段完全一致，返回新实例的引用。 |
| Finalize | 虚方法，在垃圾回收器判断对象应该作为垃圾被回收之后，在对象的内存被实际回收之前调用。需要在回收内存前执行清理工作的类型应重写该方法。 |

CLR要求所有对象都用new操作符创建。

```c#
Employee employee = new Employee("Jonah");
```

以下是new操作符所做的事情：
1. 计算类型及其多有基类型中定义的所有实例字段需要的字节数。
2. 从托管堆中分配类型要求的字节数，从而分配对象的内存，分配的所有字节都设为0。
3. 初始化对象的“类型对象指针”和“同步块索引”成员
4. 调用类型的实例构造器，传递在new调用中传递的实参。

new执行了以上操作后，返回指向新建对象的一个引用。

new操作的细节：
1. 堆上的每个对象都需要一些额外的成员，包括类型对象指针（type object pointer）和同步块索引（sync block index）。CLR利用这些成员管理对象。额外成员的字节数要计入对象大小。
2. 大多数编译器都在构造器中自动生成代码来调用基类构造器。每个类型的构造器都负责初始化该类型定义的实例字段。最终调用System.Object的构造器，该构造器什么也不做，简单地返回。

## 二、类型转换

CLR最重要的特性之一就是类型安全。在运行时，CLR总是知道对象的类型是什么。调用GetType即可知道对象的确切类型。由于GetType是非虚方法，所以一个类型不可能伪装成另一个类型。



## 三、命名空间、程序集



## 四、运行时的相互关系
