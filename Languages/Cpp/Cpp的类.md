# Cpp的类



## 自定义数据类型

定义一个类的简单示例：

```c++
struct Sales_data{
    std::string bookNo;
    unsigned unit_sold = 0;
    double revenue = 0.0;
};
```

类以关键字`struct`开始，紧跟类名和类体（类体部分可以为空）。

类体由花括号包围形成一个新的作用域。

类体右侧表示结束的花括号后边必须写一个分号，因为类体后面也可以紧跟变量名，表示顺便定义了该类型的变量。

```c++
struct Sales_data{
    std::string bookNo;
    unsigned unit_sold = 0;
    double revenue = 0.0;
}data, newdata;
```

一般而言，最好不要吧对象的定义和类的定义放在一起。这么做无异于把两种不同实体的定义混在一条语句里。

当在函数体外部定义类时，在各个指定的源文件中可能只有一处该类的定义。而且，如果要在不同文件中使用同一个类，类的定义就必须保持一致。

为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应该与类名一致。

头文件通常包含那些只能被定义一次的实体，如类、const、constexpr变量等。头文件也经常用到其他头文件的功能。

头文件一旦改变，相关的源文件必须重新编译以便获取更新过的声明。

**预处理器**可以确保文件多次包含仍能安全工作。预处理器是在编译之前执行的一段程序，可以部分改变开发者所写的程序。

当预处理器看到`#include`标记时就会用指定的头文件的内容代替`#include`。

还有一项预处理功能是**头文件保护符**，头文件保护符依赖于预处理变量，预处理变量有两种状态：已定义和未定义。`#define`指令把一个名字设定为预处理变量，另外两个指令分别检查某个指定的预处理变量是否已经定义：`#ifdef`当且仅当变量已经定义时为真，`#ifndef`当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到`#endif`指令为止。

使用以上功能可以有效放置重复包含发生，例如：

```cpp
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data{
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
}
#endif
```

预处理变量无视C++中关于作用域的规则。

整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法时基于头文件中类的名字来构建保护符的名字，以确保唯一性。为了避免与程序中其他实体发生名字冲突，一般把预处理变量的名字全部大小写。



## 类

当然也可以使用关键字`class`定义类

