# Unity脚本编程数学基础

数学对游戏的重要性

以3D游戏为例，原始的3D模型是一系列顶点和顶点之间的连接关 系，模型制作者将坐标等数据以纯数字形式保存到文件里，游戏引擎 的任务则是将数字转化成模型展现在用户面前。游戏引擎从模型的原 始数据开始，逐步加入场景、摄像机、光照等因素，按一套标准的流 程进行计算，最终将模型展现出来。

## 坐标系

### 世界/局部坐标系、左/右手坐标系

**全局坐标系**是场景内所有物体和方向的基准，也称**世界坐标系**。 在全局坐标系中的原点(0, 0, 0)是所有物体位置的基准，且全局坐标系指定了统一的x轴、y轴和z轴的朝向。

常见的三维软件都采用**笛卡尔坐标系**，也就是常见的用x轴、y 轴、z轴坐标描述物体的坐标信息。笛卡尔坐标系可以是左手坐标系也 可以是右手坐标系

**Unity采用左手坐标系**，且**x轴**、**y轴**和**z轴的**默认方向分别为**右**、**上**、**前**。

熟记Unity坐标系顺序

熟悉并记住Unity中坐标轴和朝向的对应关系，可以极大提高场 景编辑和编写代码的效率。

右，x轴；

上，y轴；

前，z轴。

x轴对应：右，(1, 0, 0)，红色，Vector3.right。

y轴对应：上，(0, 1, 0)，绿色，Vector3.up。

z轴对应：前，(0, 0, 1)，蓝色，Vector3.forward。

每个物体都有它的局部坐标系，局部坐标系会随着物体进行移 动、旋转或缩放，局部坐标系也称本地坐标系。

在Unity中，局部坐标系与 “父子关系”这一概念密切相关，父物体的位置、旋转、缩放影响着 它所定义的局部坐标系，而所有的子物体都是以这个局部坐标系定位的。

理解世界坐标系与局部坐标系的关键：

任何坐标数值在不同坐标 系中有着不同的解释。例如，Vector3.up是局部坐标系还是世界坐标 系？

答案是无法判断。其实Vector3.up的数值是固定的(0, 1, 0)，而 (0, 1, 0)具体代表什么，则完全取决于它是相对什么而言的。

```c#
// 物体向着世界上方移动一米
 transform.position += Vector3.up;
 // 物体向自身的上方移动一米
 transform.Translate(Vector3.up);
 // 上面一句代码等价于下面这句
 transform.position += transform.up;
 // 错误的写法会导致计算结果意义不明
 transform.Translate(transform.up); // !!! 错误的写法
```

### 屏幕坐标系

通过`Input.mousePosition`可以获得鼠标指针在屏幕上的位置，类型为`Vector2`。这个位置是以原始的“像素”为单位的，如Game窗口分 辨率为1920像素×1080像素，那么鼠标指针位置的取值范围就是从左 下角的(0，0)到右上角的(1919，1079)，这就是屏幕坐标系的原始取值。

可以通过摄像机的`ScreenToViewportPoint()`方法，将原始的屏幕 坐标转化为视图空间中的一点。通过该方法形成的坐标系称为视图坐 标系，这个空间位置具有x、y和z共3个分量。z分量暂不讨论，而x分 量和y分量取值范围在0~1之间，一般情况下就是屏幕坐标系位置归一 化得到的，也就是说左下角是(0，0)点，右上角是(1，1)点，屏幕正中央则是(0.5，0.5)。

```c#
// 鼠标指针位置是屏幕坐标系
Vector2 mousePos = Input.mousePosition;
Debug.Log("鼠标指针在屏幕上的位置：" + mousePos);
// 将鼠标指针位置转化为视图坐标系时，需要利用摄像机计算
Vector3 viewPoint = Camera.main.ScreenToViewportPoint(Input.mousePosition);
Debug.Log("鼠标指针位置的视图坐标为：" + viewPoint);
```

## 向量

向量是一个极其有用的数学概念，它具有两个基本要素：大小和方向。换句话说，只要能表示大小和方向的方法都可以表示向量。向量至少有两种表示方法：几何表示法和坐标表示法。

**几何表示法**：画出一个箭头，箭头方向代表向量的方向；箭头的起点代表向量起点，箭头终点代表向量终点，线段的长度就是向量的长度。

**坐标表示法**：在空间中建立坐标系，将向量从起点移动到坐标系原点，向量终点的坐标值就可以表示向量。

还有其他方法可以表示向量。例如，可以用一个长度为1的向量表示方向，再用另一个数字表示向量长度；也可以用一个角度代表方向，一个值代表长度。总之，只要能准确表示出大小和方向，就可以正确表示一个向量。

**位置（坐标点）与向量的关系：**

一般来说，一个向量的起点是可以自由移动的，但无论怎么移动，向量也不会有变化。而坐标系中的一个点，代表着一个特定的位置。

### 向量的点积

两个向量的点积是一个标量，其数值为两者长度相乘，再乘以两者夹角的余弦：

a·b=|a|·|b|cosθ

用坐标表示，公式为：

(x1,y1,z1)·(x2,y2,z2)=x1x2+y1y2+z1z2

注意到，两个向量的点积是一个数（标量），只有大小，没有方向。

点乘满足交换律，如向量a·b=b·a。

#### 点乘的意义

##### 快速判断两个向量的夹角

由于夹角的余弦具有正负值，因此通过两个向量的点积正负，可以快速判断两个向量的夹角。

若点积等于0，则两者垂直；

若点积大于0，则两者夹角小于90°；

若点积小于0，则两者夹角大于90°。

##### 投影距离

a·b=|a|·|b|cosθ = |a|cosθ =  |a'|		(|b| = 1)

注意，这样得到的结果是一个数（标量），代表a'的大小。

```c#
Vector3 a = new Vector3(2,1,0);
Vector3 b = new Vector3(3,0,0);
Vector3 dir_b = b.nomalized; //dir_b是标准化的向量b
float pa = Vector3.dot(a,dir_b); //pa即是向量a在向量b方向的投影长度
```

### 向量的叉积

两个向量的叉积是一个新的向量，新向量垂直于原来两个向量所构成的平面。叉积的方向用左手定则判断。

a x b=|a|·|b|sinθ 

当向量a与向量b共线（同向或反向）时，叉积为0向量。

两个向量叉乘的顺序不同，手掌转向会不同，结果方向相反，因此叉乘不满足交换律。

在游戏开发中也经常会使用叉积，因为叉积有着一个**重要的用途** ——**求法线**

简单来说，法线就是垂直于平面的线，用法线可以方便地指代平面的朝向。

在游戏开发中，平面要区分正反两面，因此法线用向量表示，法线方向就是平面的方向。一般法线长度固定为1以便计算。

有了叉积，很多时候可以方便地获取法线。例如，玩家站在地形 的一个平面上，想要获取平面法线，需要先用其他方法获得平面上的任意两个向量，只要这两个向量夹角不为0°或180°，取它们的叉积就可以获得法线向量（也可以将叉积结果标准化）。

```c#
Vector3 a = new Vector3(2,1,1); //a和b是某个平面上的任意两个向量
Vector3 b = new Vector3(3,0,2);
Vector3 n = Vector3.Cross(a,b); //n是该平面的法线
n = n.nor m alized; //将n标准化
```

### Vector3结构体

C#中有**类**（class）和**结构体**（struct）区别，虽然它们都具有字段、属性和方法，但是前者是**引用类型**，后者是**值类型**，在使用时区别不小。Vector2和Vector3属于结构体。

在Unity中，与向量有关的结构体有Vector2、Vector3，分别用来 表示二维向量和三维向量，其中Vector3最为常用。

| 字段或属性   | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| x            | 向量的x分量                                                  |
| y            | 向量的y分量                                                  |
| z            | 向量的z分量                                                  |
| normalized   | 得到标准化向量（方向相同，长度为1）                          |
| magnitude    | 得到向量长度，长度是标量                                     |
| sqrMagnitude | 得到向量长度的平方。运算速度比得到长度要快，因为少一步开方运算。在仅比较两个长度，不需要精确求出长度时非常有用 |

| 方法       | 说明                         |
| ---------- | ---------------------------- |
| Cross()    | 向量叉乘                     |
| Dot()      | 向量点乘                     |
| Project()  | 计算向量在另一个向量上的投影 |
| Angle()    | 返回两个向量的夹角           |
| Distance() | 返回两个向量的距离           |

**坐标与向量的关系：**

| 元素1 | 运算符 | 元素2 | 一般意义                                                     |
| ----- | ------ | ----- | ------------------------------------------------------------ |
| 坐标  | +      | 坐标  | 无意义。特殊情况如(A+B)/2可以得到线段的中点                  |
| 坐标  | +      | 向量  | 从某个坐标位移一段距离。得到新的坐标                         |
| 向量  | +      | 向量  | 叠加得到一个新的向量，向量a加向量b，得到的向量a+b，它从向量a的起点指向向量b的终点。 |
| 坐标  | -      | 坐标  | 得到一个向量，从第2个位置指向第1个位置                       |
| 坐标  | -      | 向量  | 得到新的坐标，相当于加上负向量                               |
| 向量  | -      | 向量  | 得到一个向量，向量a减去向量b，得到的向量a-b，它从向量b的终点指向向量a的终点。 |

### 向量坐标系的转换

局部坐标转换为世界坐标：`transform.TransformPoint()`

世界坐标转换为局部坐标：`transform.InverseTransformPoint()`

**向量**的全局坐标系和局部坐标系之间的转换：

`transform.TransformDirection()`

`transform.InverseTransformDirection()`

**例子：**

沿着自身的z 轴方向慢慢移动：

```c#
using UnityEngine;
public class CoordinateLocal:MonoBehaviour{
    void Update(){
        transform.Translate(Vector3.forward * Time.deltaTime);
    }
}
```

沿着世界坐标系的z轴方向移动：

```c#
using UnityEngine;
public class CoordinateWorld:MonoBehaviour{
    void Update(){
        Vector3 v = transform.InverseTransformDirection(Vector3.forward);
        transform.Translate(v * Time.deltaTime);
    }
}
```

`transform.Translate()`函数**默认是以局部坐标系为基准**的，因此在第1个脚本中，虽然`Translate()`函数参数为`Vector3.forward`，但是 依然会以局部坐标系的前方为准。`Vector3.forward`的值是常数 (0,0,1)，它在不同的坐标系代表不同的“**前方**”。

第2个脚本稍微复杂一点，把世界坐标系的“前方”转化为局部坐标系的向量v。这里认为`Vector3.forward`是世界坐标系的“前方”，用`InverseTransformDirection()`方法将向量(0,0,1)以局部坐标系表示（也就是向量v），然后以v作为参数执行`Translate()`方法，就会使立方体朝世界坐标系的前方移动了。

## 矩阵

3D游戏中的向量一般只有3个维度，但矩阵要使用4×4 矩阵，主要原因是要用矩阵实现平移，3×3矩阵是不够的。4×4 矩阵是能够正常进行所有常用变换的最小矩阵。

### 常用矩阵

#### 平移矩阵

$$
T(p) =
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0\\
p_x & p_y & p_z & 1
\end{bmatrix}
$$

向量v乘T(p)，相当于让向量v的x、y、z分量分别变化px、py、 pz。

#### 旋转矩阵

$$
X(θ) =
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & cosθ & sinθ & 0\\
0 & -sinθ & cosθ & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

向量v乘X(θ)，可以让向量沿着x轴旋转θ角。

#### 缩放矩阵

$$
S(q) =
\begin{bmatrix}
q_x & 0 & 0 & 0\\
0 & q_y & 0 & 0\\
0 & 0 & q_z & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

向量v乘S(q)， v的3个分量分别缩放qx、qy、qz倍。

矩阵变换最强大的地方在于，它可以通过矩阵乘法进行组合，组 合以后通过一个矩阵就可以表示一组连续的变换操作，假设有3个矩阵 S、R、T分别进行缩放、旋转、位移操作，三者相乘得到了M矩阵。那么
$$
vSRT=vM
$$
用向量v依次乘S、R、T矩阵以进行变换，得到的结果和向量v直接乘M矩阵得到的结果是一致的。

### 齐次坐标

在3D数学中，齐次坐标就是将原本的三维向量(x, y, z)用四维向量(x, y, z, w)来表示。

引入齐次坐标有如下目的：

1. **更好地区分坐标点和向量。**

   在三维空间中，(x, y, z)既可以表示 一个点，也可以表示一个向量。如果采用齐次坐标，则可以使用(x, y, z, 1)代表坐标点，而用(x, y, z, 0)代表向量。在进行一些错误 操作时，例如将两个坐标点相加，会立即得到一个错误的结果，避免引起混乱。

2. **统一用矩阵乘法表示平移、旋转和缩放变换。**

   3×3的矩阵可以用于表示旋转和缩放矩阵，但是无法表示平移。用4×4的矩阵就可以表示所有的常用变换，包括平移、旋转、缩放、斜切，以及它们的组合。

### 四元数

#### 万向节锁定

虽然可以调整欧拉角到任意角度，但欧拉角的3个轴并不是独立 的，x轴、y轴和z轴之间存在**嵌套结构**。这种嵌套结构被称为“**万向节**”，意思是可以转到任意角度的关节。

当中层轴旋转时，会带动内层的轴跟着旋转。

通常三维软件的欧拉角，从外层到内层是按照y轴→x轴→z轴的顺序，也就是说沿x轴的旋转会影响z轴。

一旦进入”万向节锁定“状态，物体旋转就会受限制。如果游戏系统是基于欧拉角设计的，那么在主角会俯仰运动的游戏，特别是空战游戏中，万向节锁定问题会显得非常严重，如飞机在俯冲时的操纵就会变得很奇怪，而且在其他类型游戏中也会带来各种各样的问题。

**注意：Unity引擎内部并没有万向节锁定问题。**

Unity内部是用四元数表示物体的旋转，不会遇到锁定问题。

四元数能够让我们跨越欧拉角，彻底解决旋转难题。

#### 四元数的概念

四元数包含一个标量分量和一个三维向量分量，四元数Q可以记作
$$
Q=[w,(x,y,z)]
$$
在3D数学中使用单位四元数表示旋转，下面给出四元数的公式定 义。对于三维空间中旋转轴为n，旋转角度为a的旋转，如果用四元数 表示，则4个分量分别为：
$$
w=cos(α/2)\\

x=sin(α/2)cos(β_x)\\

y=sin(α/2)cos(β_y)\\

z=sin(α/2)cos(β_z)\\
$$
用四元数表示旋转一点也不直观，4个分量w、x、y和z与绕各轴的 旋转角度并没有直接的对应关系。在实际游戏开发中不要试图获取和 修改某一个分量，应当只做整体处理。

前面提到，矩阵也可以表示旋转，而且矩阵也不存在万向节锁定 问题。其实，旋转还可以用欧拉角和四元数表示，但是每一种表示方 法都有其各自的优缺点。

|                | 欧拉角           | 矩阵           | 四元数           |
| -------------- | ---------------- | -------------- | ---------------- |
| 旋转一个位置点 | 不支持           | 支持           | 不支持           |
| 增量旋转       | 不支持           | 支持，运算量大 | 支持，运算量小   |
| 平滑差值       | 支持（存在问题） | 基本不支持     | 支持             |
| 内存占用       | 3个浮点数        | 16个数值       | 4个浮点数        |
| 表达式是否唯一 | 无数种组合       | 唯一           | 互为负的两种表示 |
| 潜在问题       | 万向节锁定       | 矩阵蠕变       | 误差累计         |

#### Quaternion结构体

| Quaternion属性  | 说明                                                     |
| --------------- | -------------------------------------------------------- |
| x               | 四元数的x分量，不应直接修改                              |
| y               | 四元数的y分量，不应直接修改                              |
| z               | 四元数的z分量，不应直接修改                              |
| w               | 四元数的w分量，不应直接修改                              |
| this[int index] | 允许通过下标运算符访问x、y、z、w分量。例如`[1]`可以访问y |
| eulerAngles     | 获得对应的欧拉角                                         |
| identity        | 获得无旋转的四元数                                       |

| Quaternion方法    | 说明                                                   |
| ----------------- | ------------------------------------------------------ |
| ToAngleAxis       | 将旋转转换为一个轴和一个角度的形式                     |
| SetFromToRotation | 与FromToRotation类似，但是直接修改当前四元数对象       |
| SetLookRotation   | 与LookRotation类似，但是直接修改当前四元数对象         |
| *                 | 四元数相乘，代表依次旋转的操作                         |
| ==                | 判断四元数是否相等                                     |
| !=                | 判断四元数是否不相等                                   |
| Dot               | 两个旋转点乘                                           |
| AngleAxis         | 根据一个轴和一个角度获得一个四元数                     |
| FromToRotation    | 获得一个轴和一个角度获得一个四元数                     |
| LookRotation      | 给定前方和上方向量，获得一个旋转                       |
| Slerp             | 插值，根据比例在两个四元数之间进行球面插值             |
| Lerp              | 插值，根据比例在两个四元数之间进行插值，并将结果规范化 |
| RotationTowards   | 将旋转from变到旋转to                                   |
| Inverse           | 返回四元数的逆                                         |
| Angle             | 返回两个旋转之间的夹角                                 |
| Euler             | 转换为对应的欧拉角                                     |

