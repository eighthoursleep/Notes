# Unity脚本基础



**新建脚本的方法（2种）：**

1. 在工程窗口的某个文件夹内右键菜单里创建。
2. 选中要添加脚本的物体，在检视窗口中点击Add Component按钮，选择New Script选项。



**给物体挂载脚本的方法（2种）：**

1. 拖拽工程窗口中的脚本文件到场景中的物体上。
2. 拖拽工程窗口中的脚本文件到检视窗口里最下边。



**创建脚本注意事项：**

1. Unity规定，能够挂在到物体上的脚本必须是“脚本组件”（区别于不是组件的脚本文件），脚本组件要继承自MonoBehaviour，且脚本代码中的class名称必须于文件名一致。一般脚本创建时会自动生成部分内容，但如果修改了脚本文件名，那么在挂载时就会报错。这时就必须修改文件名或class名称，让它们一致，这样才能正确挂载。
2. Unity支持一个物体挂载多个同样的脚本组件，但一般来说只需要一个。如果由于操作失误挂载了多个脚本组件，就要删除多余的，这也是建议把脚本文件拖拽到检视窗口内的原因，这样易于确认是否挂载了多个脚本组件。



**Start事件、Update事件：**

`Start()`函数在游戏开始运行的时候执行一次，特别**适合进行组件 初始化**。

`Update()`函数**每帧都会执行**，在**不同设备上更新的频率有所区别**，特别是当系统硬件资源不足时，帧率就会降低，因此`Update()`函数**实际执行的频率是变化的**。

Start和Update又被称为“事件”，因为它们分别是在“**该组件开始运行**”和“**更新该组件**”这两个事件发生时被调用的**。**



## 控制物体移动的基本操作



### 修改物体位置

在Unity里修改物体位置，实际上就是修改Transform（变换）组 件的数据。

在界面中可以修改的参数在脚本中也能修改，而在脚本中可以修改的参数就不一定会在界面上出现了，因为脚本的功能比界面上展示 的功能要多得多。

修改Transform组件中的Position有2种常用方法：

1. 使用`Translate()`方法

   ```c#
   // 物体将沿着自身的右侧方向(X轴正方向也称为向右)前进1.5个单位
   transform.Translate(1.5f, 0, 0);
   ```

2. 直接指定新的位置。

   ```c#
   transform.position = new Vector3(1, 2.5f, 3);
   ```

根据C#语法的规定，直接写2.5会被认为是double类型的数，而这里需要的是float类型的数，因此必须加后缀**f**。使用`new`是因为`Vector3`是一个值类型，而position是一个属性，由于C#中引用和值的原理，不能使用`transform.position.y = 2.5f`这种写法直接修改物体的位置。

如果要做一个连续的位移动画，只需要让物体每帧都移动一段很小的距离就可以了。也就是说，可以把改变位置的代码写在Update() 函数里，但是每帧都要比前一帧多改变一些位置。

```c#
void Update () {
	transform.Translate(0, 0, 0.1f);
    //或者:
    //transform.position += new Vector3(0, 0, 0.1f);
}
```

注意，物体位置的两种写法有本质区别：Translate()函数默认为局部坐标系，而修改position的写法是以世界坐标系为参考系。

由于系统繁忙时无法保证稳定的帧率，因此对于上面的写法，如果帧率高，小球移动就快；帧率低，小球移动就慢。

我们需要在“每帧移动同样的距离”和“每秒移动同样的距离”之间做出选择。 按游戏开发的常规方法，应当选择“每秒移动同样的距离”。

举个例子，如果帧率为60帧/秒时物体每帧移动0.01米，那么帧率只有30 帧/秒时就应该每帧移动0.02米，这样才能保证物体移动1秒的距离都是0.6米。

修改如下：

```c#
void Update () {
 transform.Translate(0, 0, 5 * Time.deltaTime);
 //或者:
 //transform.position += new Vector3(0, 0, 5 * Time.deltaTime);
 }
```

`Time.deltaTime`表示两帧之间的间隔，如帧率为60帧/秒时这个值为0.0167秒，帧率只有10帧/秒时这个值为0.1秒，用它乘以移动速度 就可以抵消帧率变化的影响。

由于`Time.deltaTime`是一个比较小的数，因此速度的数值应适当放大一些。



### 读取和处理输入

Unity支持多种多样的输入设备，如键盘、鼠标、手柄、摇杆、触摸屏等。很多输入设备有着类似的控制方式，如按键盘上的W键或上箭 头键，将手柄的左摇杆向前推，都代表“向上”，用Unity的术语表述则是“沿纵轴（Vertical）向上”。以下代码就可以获取用户当前的纵轴输入和横轴输入。

```c#
void Update () {
    float v = Input.GetAxis("Vertical");
    float h = Input.GetAxis("Horizontal");
    Debug.Log("当前输入, 纵向:"+ v + " " + "横向:" + h);
    transform.Translate(h*10*Time.deltaTime, 0, v*10*Time.deltaTime);
}
```

`Input.GetAxis()`函数的返回值是一个float类型的值，取值范围 为-1~1。

Unity默认将public字段直接放在界面上，用户可以随时修改public字段的值，并且被修改的参数会在下一次Update()函数执行时立即生效。

唯一需要注意的是，运行时的改动都不会被自动保存，需要在调整时记下合适的数字，停止运行后手动修改。

### 摄像机的移动

摄像机移动的方法（2种）：

1. 像控制物体/角色移动一样为摄像机挂载控制脚本，使其与物体/角色保持同步运动。
2. 更为简单直接地，将摄像机设置为物体/角色的子物体，此时摄像机在没有其他代码控制的情况下会与物体/角色保持相对静止，随着物体/角色移动。



## 触发器事件

抛开高级游戏引擎提供的各种技术，直接判断物体之间的距离就足以实现碰撞检测，即两个物体之间的距离小于某个值，就是碰到了。早期的游戏就是这么做的，不过Unity等现代游戏引擎给出了更统一、更简便的方法——使用触发器。

**触发器**是一个组件，它定义了一个范围。当其他带有碰撞体组件 的物体进入了这个范围时，就会产生一个触发事件，脚本捕捉到这个 事件的时候，就可以做出相应的处理。

### 创建触发器

在Unity中，触发器和碰撞体共用了同一种组件——Collider，实 际上两者是不同的概念。勾选Box Collider面板中的Is Trigger选 项，碰撞体就变成了同样外形的触发器。

并不是任何物体进入触发器的范围都会产生触发事件。

### 触发器事件函数

碰撞和触发总是发生在两个物体之间，所以根据不同情况，可以选择其中一个物体进行碰撞或触发的处理。

触发事件实际上有3种，即开始触发（OnTriggerEnter）、触发持续中（OnTriggerStay）及结束触发（OnTriggerExit），分别代表另 一个物体进入触发范围、在触发范围内、离开触发范围这3个阶段。

**提示：**

删除不必要的事件函数是一种良好的编码习惯，可以减少不必要的函数执行。即使是函数体为空的函数，执行时依然会消耗CPU资源。



**小知识：**

**按住Ctrl键拖曳物体的作用**

按住Ctrl键拖曳物体会让其以一个固定值移动（可以在 Edit→Snap Settings中修改这个固定值），调整物体的旋转和缩放时也是同理。这个功能在搭建场景时可以很方便地对齐物体的位置，特别是当物体为同一规格大小时。

**什么是预制体？**

预制体简单来说就是一个事先定义好的游戏物体，之后可以在游戏中反复使用。最简单的创建预制体的方法是直接将场景内的物体拖曳到Project窗口中，这时在Hierarchy（层级）窗口中所有与预制体关联的物体名称都会以蓝色显示（普通物体的名称是黑色）。

**`Time.timeScale`是什么？**

`Time.timeScale`表示游戏的运行时间倍率，设置为0即表示游戏里的时间停滞，1即正常的时间流逝速度，2即两倍于正常的时间流逝速度，以此类推。