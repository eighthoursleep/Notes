# Unity业务逻辑优化技巧

[TOC]

说到优化，一般会想到渲染、drawcall、Overdraw、引擎算法、底层组件以及大型的整套解决方案，很少会关注普业务逻辑中的问题。

下边将介绍如何优化不起眼却蕴含巨大潜力的性能问题。

## 使用List和Dictionary时提高效率

List、Dictionary的实质都是数组。

Dictionary有两个数组，一个数组保存索引，另一个数组保存数据。

当往List里插入新元素时，这是在向数组写入元素，并遍历其后边的数据依次向后移动的过程。

了解这点对每次使用List的Insert都会更加注意。

Contains()函数是一个以遍历形式来寻找结果的函数，每次使用它，都会从头到尾遍历一次，直到寻找到结果。

Remove()也一样，也是以遍历的形式存在。

如果在代码中频繁使用，会带来不必要的性能消耗。

Dictionary也有诸多问题，首先它是一个使用Hash冲突方案来解决关键字的字典组件，因此Hash值与容器中数组的映射和获取Hash值的函数GetHashCode()比较关键。

Hash冲突与数组大小有很大关系，数组越大，Hash冲突率越小，因此我们应注意设置Dictionary的初始大小，尽量设置一个合理的大小，而不是什么都不做，任由其自己扩容，这不但会让Hash值冲突频繁，而且扩容时数组的回收也加重了GC单元的负担。

除此之外，在C#中，所有类都继承自Object类，Dictionary使用Object类的GetHashCode()获取类实例的Hash值，而GetHashCode()是用算法将内存地址转化尾哈希值的过程，因此，我们可以认为它只是一个算法，并没有对任何值做缓存，每次调用它都会计算一次Hash值，这是比较隐性的性能损耗。

如果频繁使用GetHashCode()作为关键字来提取Value，我们应该关注GetHashCode()的算力损耗，并确认是否可以用唯一ID的方式来代替GetHashCode()算法。

## 巧用struct

struct是值类型，与class不同的是，struct传递时并不是靠引用（指针）形式而是靠复制，我们可以通俗地认为，它是通过内存复制来实现传递的（真实情况是通过字节对齐规则循环多次复制内存），也就是说，我们在传递struct时，其实是在不断地克隆数据。

例子：

```c#
struct MyStruct{
    public int coin;
}
public void main()
{
    MyStruct struct1 = new MyStruct();
    struct1.coin = 10;
    MyStruct struct2 = struct1;//struct1赋值给struct2，改变struct2不会改变struct1，这俩是不同的内存
    struct2.coin = 90;
}
```

像struct这样的值类型对性能优化有什么好处？

如果struct被定义为函数中的局部变量，则struct的值类型变量分配的内存是在栈上的，栈是连续内存，并且在函数调用结束后，栈的回收非常快速和简单，只要将尾指针置零即可（不是真正意义上的释放内存），这样既不会产生内存碎片，又不需要内存垃圾回收，CPU读取数据对连续内存非常友好、高效。

除此之外struct数组对提高内存访问速度也有帮助。

由于struct是值类型，它的内存与值类型都是连续的，而class数组只是引用（指针）变量空间连续。

在CPU读取数据时，连续内存可以帮助我们提高CPU的缓存命中率，因为CPU在读取内存时会把一个大块内容放入缓存，当下次读取时先从缓存中查找，如果命中则不需要再向内存读取数据（缓存比内存快100倍），非连续内容的缓存命中率比较低，而CPU缓存命中率的高低很影响CPU的效率。

如果struct太大，超过了缓存复制的数据块，则缓存不再起作用，因为复制进去的数据只有1个甚至半个struct。于是有很多框架抛弃了struct，彻底使用原值类型（int[], bool[], byte[],float[]等）连续空间的方式来提高CPU的缓存命中率，即把所偶数值都集合起来用数值的形式存放，而再具体对象上则只存放一个索引值，当需要存取时，都通过索引来操作数组。

例子：

```c#
class A
{
    public int a;
    public float b;
    public bool c;
}
class B
{
    public int index;
}
class C
{
    private static C _instance;
    public static C instance;
    {
        get
        {
            if(null == _instance)
            {
                _instance = new C();
                return _instance;
            }
            return _instance;
        }
    }
    public int[] a = new int{2,3,5,6};
    public float[] b = new float{2.1f,3.4f,1.5f,5.4f};
    public bool[] c = new bool{false,true,false,true};
}
public void main()
{
    A[] arrayA = new A[3]{new A(),new A(),new A()};
    print("A class, a {0}, b {1}, c {2}",A[0].a, A[0].b, A[0].c);
    
    B.b = new B();
    b.index = 2;
    
    C c = C.instance;
    
    print("B class, a {0}, b {1}, c {2}",c.a[b.index],c.b[b.index],c.c[b.index]);
}
```

A类使用我们非常熟悉的面向对象编程方式把所有属性变量都放在了自己身上，数据的集合则以索引的方式存储再数组上。

B类将数据存储在C类中。

当两者都对数据进行存取时，A类数据的内存是分散的，因为每次分配A类实例时都是从内存中寻找一块空地来分配，并不保证相邻。

arrayA中只是引用连续而非内存连续，而B类数据是内存连续的数组，因为它会将所有同类数据集中在值类型的数组中，值类型的数组分配一定是内存连续的，这样就能更好的利用缓存，提高CPU读取数据的命中率。

缓存机制是将最近使用过的数据存入最近的空间中，离CPU最近的就是一级缓存和二级缓存，它们是珍贵的，应该充分利用。



## 尽可能使用对象池

除了减少内存分配次数和内存碎片，还要避免内存卸载带来的性能损耗。

Unity使用的是C#语言，因此它使用垃圾回收机制回收内存，即使在发布后C#转换尾C++，也依然会使用垃圾回收机制来执行分配和销毁内存。

在创建类实例时，内存分配时的性能消耗以及垃圾回收很艰难。有多难？

在C#中我们可以随意地新建类实例，由于不用管它们的死活，可以丢弃或空置引用变量。类实力不断被引用和间接引用，又不断被抛弃，垃圾回收器就要负责仔细收拾我们的烂摊子。内存不可能永远被分配而不回收，于是垃圾回收只能在内存不够用的时候导出询问和检查（即遍历多有已分配的内存块），看看哪个实例完全被遗弃（完全没人引用了）就捡回来，并将内存回收。

当业务逻辑越大，数据量越多的时候，垃圾回收需要检查的内容也越多，如果回收后依然内存不足，就得像系统请求分配更多内存。

每次回收都会占用大量CPU算力，因此，我们应该尽可能使用对象池来重复利用已经创建的对象，这有助于减少内存分配时的消耗，也减少了堆内存的内存块数量，最终减少了垃圾回收时带来的CPU损耗。

## 字符串导致的性能问题



## 字符串的隐藏问题



## 程序运行的原理

