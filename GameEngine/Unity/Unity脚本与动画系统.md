# Unity脚本与动画系统



## 动画系统的基本概念

动画的基本概念有帧、帧动画与2D/3D骨骼动画等，现代游戏开发 中还加入了动画融合、动画状态机等相关的概念。

### 动画的基本概念

#### 帧

在古代一幅字画叫一帧，而在计算机中，**每次渲染完毕一幅画面并显示出来，这一幅图就是一帧。**

连续切换的帧就形成了动态的画面。**每秒刷新帧的次数**称为**帧率**，单位是“FPS（Frames Per Second，帧/秒）”，也可以简称为 “帧”。

传统电影每秒显示24帧就可以保证良好的动态效果。由于游戏与电影显示原理的不同，游戏至少需要30帧才能感到流畅，而要保 证良好的视觉体验则最好是能达到60帧。

作为用户当然希望帧率尽可能稳定，但在游戏运行过程中，设备 不一定能维持稳定的帧率。当运算负载较高时，Unity就会降低画面和 逻辑的更新次数。

#### 帧间隔时间`Time.deltaTime`

Unity会记录**每一帧开始时间与上一帧时间的差值**，保存到 `Time.deltaTime`属性中。

开发者通过查询`Time.deltaTime`，就可以 知道实际上当前帧相比前一帧过去了多少秒（实际时间），利用此 时间可以对逻辑速度进行修正。

在动画系统底层已经考虑了这种修正，让动画播放帧率与真实 的时间流逝相匹配。

#### 帧动画

帧动画是最古老、也最容易理解的一种动画技术。它是**事先准备好动画中的每一帧画面，然后依次播放。**

传统手绘动画片将帧动画技术发展到了很高的水平，2D游戏也自 然借用了这一技术，只不过将拍摄动画换成了计算机处理。帧动画至 今活跃于许多卡通风格的游戏中，特别是“像素画”风格与帧动画是 绝配，不仅风格讨巧，而且降低了美术工作量。

**帧动画的优点**：简单直接、技术门槛低，美术设计师在一定范围内可以自由发挥。

**帧动画的缺点**：美术制作的工作量较大，占用的存储空间也较大 （每一帧都需要完整保存），目前主要用于2D游戏。

#### 3D骨骼动画

骨骼动画的技术思想简单来说，是将人物模型与一个类似火柴棍组成的骨架绑定在 一起，每一段火柴棍（骨骼）关联着模型的一部分，这样只需要移动 和旋转骨架，人物就会跟着做出各种动作了。

“骨骼动画”这一技术不仅节省了工作量，而且动作效果也变得更自然。

另外，同一套骨骼数据可以应用于体型相近的不同角色模型上， 这样就可以批量地制作更多的角色。实践中甚至可以**将一套骨骼和动画适配到另一套不同的骨骼模型上**，这称为“**重定向**”。

Unity对3D动画、3D骨骼动画均有较好的支持，如标准的FBX文件 （一种常用的3D模型和动画文件格式）。

在Project窗口中选中FBX文件，可以在Inspector窗口内看到导入 设置，导入设置具有Model（模型）、Rig（骨骼绑定）、 Animation（动画）和Materials（材质）4个选项。

其 中的Rig选项中，可以选择的动画类型为None（无骨骼）、Legacy（旧 版系统）、Generic（通用型）和Humanoid（人形），目前主要使用后 两者。如果是人形骨骼模型，则选择Humanoid选项，在其他情况下 （没有骨骼或不是人形角色）都可以选择Generic选项。Unity对常用 的人形骨骼有优化，功能更多，使用也更方便。

#### 2D骨骼动画

思路是，将2D角色身体的各个部分切割开，做成独立的图片，如头、胸、腹、臂和腿等，然后绑定一个2D的“火柴”组成的骨 骼，通过调整骨骼，也可以让2D角色活灵活现地动起来。

这种做法能够提高动画制作效率，同时也能提高资源利用率、显 著节约存储空间。

目前Unity对2D骨骼动画也有较好的支持，可以借助官方扩展包2D Animation直接制作2D骨骼动画，也可以使用更专业的2D骨骼动画软 件，如Spine和Dragonbones，借助相关插件导入Unity中使用。

### 动画融合

3D骨骼动画和2D骨骼动画都有一个共同的特点：动画被抽象化、 数据化了，计算机能够表示帧与帧之间的联系，甚至能直接计算出两 帧之间的过渡状态。动画设计师只需要指定一个动作中的关键几个帧 （关键帧），其他的帧（过渡帧）可以利用数学算法进行插值计算 （线性插值或其他插值算法）。

以此类推，不仅同一个动作的各个关键帧之间可以自动计算过渡 帧，而且不同动作之间也可以计算过渡帧。再进一步，如果动画设计 师提供了“慢走”和“疾跑”两个动作，甚至还可以通过插值计算出 慢跑、中速跑等更多介于慢走和疾跑之间的动作。这种在不同动作之 间自动计算过渡状态的技术称为“动画融合”。

Unity对动画融合有很好的支持，在动画状态机中有专用的融合树 （Blend Tree），它支持一个或两个维度的动画融合。“两个维度” 指的是两种运动方式，如常用的“转身”和“前进”就是两个维度， 利用Blend Tree可以混合出慢走并快速左转，或者快走并慢速右转等 不计其数的动作。

**注意**，在**帧动画中，动画的每一帧都是相对独立的。**帧动画的数据**没有抽象化、数据化**，就**不可能进行动画融合**。因此，如果是采用帧动画技术制作的游戏，就不用考虑动画融合。

### 动画状态机

目前，几乎所有的Unity游戏在制作动画时都要用到动画状态机 （Animator），动画状态机目前已经是游戏开发的标准配置。

理论上来说动画状态机并不是必需的。

特别是对采用帧动画制作的游戏来说，帧动画本质就是图片的切换，那么只要及时切换图片，自然就能正确播放动画。

因此，用脚本直接修改图片也并无不可，不一定非要使用动画状态机。

只是在实际游戏开发中，利用动画状态机可以统一动画制作的思 路，包括2D动画、3D动画、骨骼动画和动画融合等。因此，Unity逐渐 摒弃了其他的动画管理方法，而统一用动画状态机组件管理所有动画。

**已经淘汰的Animation组件：**在某些资料中可能会看到Animation组件，它也可以指定物体的动画并播放。但是其功能过于单一，**完全可以被Animator替代**，因此现在几乎看不到它的身影了。

#### 理解动画状态机

当前处于某个状态，如果发生某件事，就切换到另一个状态。

这种思路有一个专门的名称——**状态机** （State Machine）。

状态机**在任意时刻都具有一个“当前状态”**，并且**默认会保持这一状态**，只有在**满足某个条件时，才会切换到另一个状态。**也就是说，状态机有两个要素：**状态**和**状态转移**。

用脚本直接实现状态机，只需要用一个变量保存当前状态，根据 游戏逻辑切换状态即可。

而对于动画系统来说，将状态机思想应用于 管理动画状态极为合适，具有很好的通用性。Unity所提供的动画状态机组件，就是专门用来管理动画状态，以及动画之间的切换和过渡的。

虽然动画状态转移图的设计没有固定的方法，但是一定要符合实际需要。

有了基本的状态转移图，之后还要具体指定状态转移条件。一般 转移条件是用专门的变量表示的。

### 根骨骼动画

Animator的应用根骨骼动画（Apply Root Motion）选项是为了解决“太空步”问题。

勾选它意味着开启根骨骼动画 功能，物体会根据动画自带的位移改变自身的位置。而这个位移速度是由动作设计师决定的（直接记录在动画中），而非程序控制的。

但是开启根骨骼动画功能需要以下3个条件，缺一不可：

1. 动画在制作时，本来就带有位移信息（一般2D动画不使用 这种方式）。
2. 导入动画文件时，正确导入了根骨骼动画信息。例如在导入FBX文件时可以进行配置。
3. Animator中勾选了Apply Root Motion选项。

对于使用了根骨骼动画的游戏来说，角色控制器的编写思路也会发生变化。由于通过控制动画状态机就能控制角色的移动，那么直接移动角色位置的代码就需要删除或做出修改。

## 2D动画实例分析



## 三维模型与动画的导入



## 动画进阶技术实例分析

### 动画融合树



### 第三人称角色控制的脚本分析



### 根骨骼动画的运动

#### 启用根骨骼动画的前提条件

根骨骼动画是将角色的运动交给动画负责，以达到运动轨迹完美 贴合动作的目的。Root（根）运动了，场景中的物体也就发生了运动。

美术设计师在制作角色动画时，让角色相对定位点发生位移和旋 转。这些位移和旋转会记录在动画资源中，在播放动画时，引擎会将同样的位移和旋转应用到游戏物体上，从而让物体实际发生移动和旋转。 

因此首先可以想到，要使用根骨骼动画，动画资源中必须具有位 移、旋转的信息。如果动画本身就不具有必要信息，那就不可能使用 根骨骼动画。其次，在导出动画资源时也要正确设置，这样才能让这 些信息被引擎正确识别。根骨骼动画的导入设置在3D模型和动画导入 的界面中，位于Animation标签页的下方。

以跑步动作资源HumanoidRun为例，选中其中的动画片段 HumanoidRun，可以看到以Root开头的选项有3个：

1. Root Transform Rotation，根的旋转。
2. Root Transform Position (Y)，根在y轴上的位移。
3. Root Transform Position (XZ)，根在水平面（xz平面）上的位移。

要利用动画资源中的运动信息，还需要分别详细设 置。如何设置与具体动画有关，这里给出重点的思路。

每种动画对角色的位置、旋转影响不同，设置之前首先要思考动 作是否改变实际的物体朝向和位置。例如，如果是向前跑步的动画， 就需要改变水平面（xz）的位置，不改变y轴位置，旋转不重要（直线 跑没有旋转）；如果是原地转身动画，则要改变水平位置和旋转，y轴不改变。

其次，根据需要勾选Bake Into Pose（烘焙到骨骼）选项。对重要的、确定需要改变的位置或旋转，取消勾选Bake Into Pose选项， 对不改变的值反而要勾选。

最后，如果动作基于的参考点不同，效果也会有区别。因此还要 设置每种运动的参考点，也就是Based Upon（基于的点），可以选择 Center of Mass（质心）、Feet（脚）等选项，但需要根据动画而 定，并根据实际测试效果调整。

在所有设置的下方，还有一个Motion→Root Motion Node，只有 该选项设置为None的时候，才会出现前文提到的3个Root开头的 选项。

**对Bake Into Pose选项的解释：**

人物的运动细说起来有两部分：一方面是动画设计师关心的， 表现层面的人物运动；另一方面是技术人员关心的，人物逻辑上的运动。

以跑步动作为例，逻辑上跑步直接影响水平方向的位置，这是 显然的。但对动画设计师来说，人物跑步时高低重心是有变化的， 上下颠簸才自然。但这种上下的颠簸只是视觉上的，不能真的去影 响物体的位置，换句话说，跑步时逻辑上只做水平运动，不会上下 运动。

这正是Bake Into Pose选项的作用。勾选了该选项，代表这个 运动只是骨骼运动，不属于根节点；而不勾选该选项，则代表它是 真正的根节点的运动。只有根节点的运动才会变成物体实际的运动。

#### 动画状态机与根骨骼动画

根骨骼动画正确设置后就可以直接使用了。不过游戏的需求比较灵活，有时需要开启根骨骼动画，有时需要关闭根骨骼动画，而控制的开关位于动画状态机里。

选中角色，观察它的动画状态机组件，可以看到Apply Root Motion（应用根骨骼动画）选项，它代表是否启用根骨骼动画。但是现在不能修改，提示信息是“Handled by Script（由脚本控制）”，其原因是在当前使用的脚本中有一个特殊的函数OnAnimatorMove()。

当Unity发现脚本组件中有此函数时，就会在编辑器上隐藏Apply Root Motion选项后方的方框。

为了进一步学习，可以先将整个OnAnimatorMove()函数注释掉。 等待编译后再观察动画状态机组件，会发现方框出现了。

此时运行游戏进行测试，一边移动、跳跃，一边查看方框，会发 现在跳跃时方框被取消勾选，而落地时又会被勾选，这是因为脚本中 一直在修改这一属性，其修改如下：

```c#
// 启用根骨骼动画
m _ Animator.applyRootMotion = true;
// 禁用根骨骼动画
m _ Animator.applyRootMotion = false;
```

由于脚本一直在修改这一属性，因此在编辑器里取消勾选也没有效果。如果要试验没有根骨骼动画的效果，可以将脚本中对`applyRootMotion`的赋值都改为false，这样一来角色就寸步难行了， 这也说明了这个角色的确是由根骨骼动画控制运动的。

### 动画遮罩



### 动画层



### 动画帧时间



### 反向动力学（IK）