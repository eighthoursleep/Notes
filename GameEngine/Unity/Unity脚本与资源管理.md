# Unity脚本与资源管理

游戏中的资源管理包含了多重含义，如静态资源的组织方式，资源的打包和压缩，资源何时加载到内存、何时释放都属于资源管理的范畴。

[TOC]

## Unity项目的文件夹结构

### 工程文件夹

**Assets（资产）**是最主要的文件夹，保存着所有游戏用到的资产。

**Library（库）**文件夹用于存放引擎必需的程序集和缓存资源。 Library不存在时会自动生成，不需要也不建议上传到版本仓库（如 SVN或Git仓库）中去。

**Logs（日志）**文件夹用于存放使用时产生的日志。

目前大部分Unity的官方功能扩展都通过扩展包提供，如Post Processing（后期处理）、Text Mesh Pro（高级文本渲染）等常用的 扩展包。**Packages（包）**文件夹虽与扩展包有关，但里面只保存配置文件。

所有的工程设置，包括工程对应的Unity版本都在**ProjectSettings（工程设置）**文件夹中。不能直接改动该文件夹中的内容，不然会造成版本兼容性的问题。

如果该工程正在被编辑，则会多出一个**Temp（临时）**文件夹，一旦关闭工程，该文件夹会自动消失。不要上传Temp文件夹到版本仓库。

### 资产文件夹

Assets文件夹下所有的文件都是资产的一部分，但某一些资产不 会被“打包”到最终发布的程序中，而其他资产则会被“打包”。

**“打包”**是指**包含在发布版本中**

“打包”一词也有多种含义，如有时是指将多个文件打成压缩包。这里的“打包”特指将资产放入最终发布版程序中。一个文件 会被打包，是指它会成为发布版的一部分，而不打包则是指它不会进入最终发布的程序，仅在开发阶段使用。

被打包的资源可能会被压缩，也可能不会被压缩。

要理解Assets文件夹的结构，首先要了解Assets文件夹下的几个特殊文件夹：

| 文件夹           | 是否打包 | 说明                                                         |
| ---------------- | -------- | ------------------------------------------------------------ |
| Editor           | 否       | 存放Unity编辑器专用的脚本和资源，如开发期间用的扩展工具      |
| Plugin           | 是       | 存在第三方程序库                                             |
| Resouces         | 全部     | 资源文件夹。该文件夹下所有资源都会被压缩并打包。<br />只有此文件夹下的内容才可以使用`Resource.Load`加载 |
| Streaming Assets | 全部     | 该文件夹下的所有资源会被打包到最终的发布版本中，<br />但会保持原样，不会被压缩和加密。不需要让Unity处理的文件<br />（如一些数据配置文件）适合放在此文件夹 |

除以上特殊文件夹，在其他非特殊文件夹中的资产，Unity会根据是否引用了该资源而决定是否打包。

所有非编辑器专用的脚本资产文件都会被打包。这是由于非组件脚本也可能会被引用，不能依据是否挂载到物体上来确定一个脚本是否被用到。

被打包的资产都可以看作是发布的程序的一部分，但它们都是只读的，不能在运行时改写它们。换句话说，以上文件夹都不能用于做热更新。

**为什么资源一定要有组织？**

如果直接使用原始资源文件，那么就只能通过路径和文件名定位资源，这会带来很多麻烦。首先，资源不能随意更改路径，一旦移动到其他文件夹，就会找不到资源。

其次，不容易确定资源之间的引用关系。例如，预置体资源A用到了预制体B和模型C，引擎就必须建立它们之间的联系，而且它们之间的引用信息在打包和游戏运行时都需要用到。

## META文件

在游戏的开发阶段会存在大量原始的资源和素材，如何管理它们是引擎需要考虑的。市面上的游戏引擎对原始资源的管理有以下两种主流方案。

第1种，**引擎统一打包和管理所有资产**。添加新资源时，通过统一的导入流程打包到专门的文件中，原始文件不再使用。

第2种，虽然引擎管理所有资产，但依然会**使用原始资源文件**。一些**必要的信息**（如模型的导入设置）会**写在另外的配置文件中**。

无论哪种方案，都必须对所有资产统一管理，而不能使用未处理、无记录的原始资源。

Unity会对Assets文件夹下的所有文件生成一个名称相同，扩展名为meta的文件，包括文件夹也会生 成对应的META文件。

**META文件**是一个**文本文件**，里面记录了很多必要的信息，包括**资产唯一标识符GUID**、**引用关系**和**资源导入设置的信息**等。

其中**资产唯一标识符GUID**非常重要，它会在**资源初次导入时生成**，有了它就**能准确定位资源文件**，文件的**改名**、**移动**和内容**修改**都不会使GUID变化。

**在Unity之外修改文件要注意：**

Unity的Project窗口的功能齐全，支持文件的移动、重命名和复制等操作。关键是，在Project窗口中进行文件操作，Unity会妥善处理这些改动。而如果在Unity之外操作，很可能会因找不到对应的META文件而失去对应关系。

很多时候材质丢失、导入信息被重置和引用丢失等问题，都是不恰当的文件操作引起的。

脚本的META文件内容通常比较简单，只有十几行，而某些资源 （如3D模型动画）往往有上千行，里面记录了必要的设置信息。

脚本文件对应的META文件例子：

```text
fileFormatVersion: 2 						文件格式版本
guid: 42850487fa989b342bcb1cb935a1f43d 		资源唯一标识符GUID
MonoImporter: 								脚本导入信息
    externalObjects: {}
    serializedVersion: 2
    defaultReferences: []
    executionOrder: 0
    icon: {instanceID: 0} 					图标
    userData: 								自定义数据
    assetBundleName: 						Asset Bundle(资源包)名称
    assetBundleVariant: 					资源包参数
```

**注意：**

1. **META文件与原始资源文件要一起管理。**例如，新增Assets文件或文件夹时，一定要**连同生成的META文件一同提交到版本仓库**。
2. **重命名和移动文件要在Unity内进行**，这样可以保证相应的 META文件自动完成相应操作。
3. **不能直接复制META文件，否则会导致GUID重复。复制资产时应尽量在Unity内用复制命令（快捷键Ctrl+D）进行，这样会自动生成 GUID不同的META文件。**
4. **用脚本操作资产时要注意META文件的同步，尽量使用Unity提供的API，而不要使用原始的文件进行读写操作。**这一点主要**针对编辑器脚本**，因为编辑器脚本有时会修改资源文件的内容。



## 动态加载和释放资源



### 动态加载资源

位于**Resources文件夹下的资源**都可以动态加载。

动态加载资源的方法主要有`Resources.Load()`和`Resources.LoadAll()`两种，前者用于**加载单个文件**，而后者可以**加载一个文件夹内的所有资源，结果以数组形式返回。**

重复加载相同的文件不会导致文件被多次加载， 引擎可以判断哪些资源已经被加载过了。



### 卸载资源

加载的资源会占用内存空间，不再使用资源的时候应当卸载。卸载方法有以下两个：

```c#
// 卸载一个资源
public static void UnloadAsset(Object assetToUnload);
// 自动卸载所有未使用的资源
public static AsyncOperation UnloadUnusedAssets();
```

**`UnloadAsset()`**方法用于**强制卸载一个资源**，不管它是不是正在被使用。如果卸载了正在使用的资源，则会直接影响当前场景的表现。 

而**`UnloadUnusedAssets()`**方法会用**异步方法自动卸载未被使用的资源**。但问题是，如果脚本中有一个变量正引用着某个资源，或是场景中某个忘记销毁的物体引用着某个资源，则该资源会因还在使用中 而不会被自动卸载。

可以看出，卸载背后隐含的问题要比加载多得多，对编程方法也提出了更高要求。



例子：

```c#
using UnityEngine;
public class TestResources : MonoBehaviour {
    void Start () {
        /*--- 加载资源 ---*/
        // 预制体资源用GameObject类型表示，路径不包含"Resources"和扩展名
        GameObject go = Resources.Load<GameObject> ("Prefabs/Cube");
        // 资源加载和实例化是不同的
        GameObject go2 = Instantiate(go);

        // 加载其他类型的资源
        Texture2D image = Resources.Load<Texture2D>("Images/1");
        Debug.Log(image.name);

        /*--- 卸载资源 ---*/
        // 强制卸载资源
        Resources.UnloadAsset(image);
        // 销毁物体
        Destroy(go2);
    }
}
```



## 资产包与热更新

对很多单机游戏来说，游戏的所有资源往往是与游戏本体一同发布的，资源不需要独立出来。但对于大型商业项目来讲，游戏产品还需要在**发布之后进行维护和更新**，这就**引出了Unity资产包的概念**。

### 资产包（Asset Bundle）

对于大型商业项目来讲，资源的打包和管理是不得不考虑的问题，其主要原因有以下几点：

1. 资源文件有必要**与程序主体解耦**。在程序主体不变的情况下可以方便地单独修改资源。 
2. 资源文件有必要**单独压缩和加密**。
3. 资源文件单独存在后，可以**不随程序主体一起发布**，而是**在用户使用时再联网下载**。这样有利于**减小安装文件体积**，也有利于后续的版本更新。

Asset Bundles（资产包）就是为了更好地解决资产管理问题而存在的。

简单例子：

**创建资产包：**

1. 新建一个工程。

2. 创建一个立方体和一个球体，再创建一个材质，并把材质赋给立方体和球体。

3. 导入任意一张图片，新建两个精灵物体Sprite，指定为同样的图片，分别命名为icon1和icon2。 

4. 将4个物体分别拖入Project窗口，作为4个不同的预制体。这样操作后，就有了4个预制体资源、1个材质和1张图片

5. 删除场景中的4个物体，稍后会利用资产包来还原它们。

6. 在`Assets`文件夹下创建一个文件夹，命名为`Editor`。这样该文件夹才能被识别为编辑器专用文件夹。 在该文件夹中创建脚本`BuildAssetBundle.cs`

   ```c#
   using UnityEditor;
   using System.IO;
   public class BuildAssetBundle
   {
       // 在主菜单中增加选项
       [MenuItem("Asset Bundles/Build AssetBundles")]
       static void BuildAllAssetBundles()
       {
           // 要创建的文件夹名称
           string dir = "AssetBundles";
           // 如果不存在该文件夹则新建它
           if (Directory.Exists(dir) == false)
           {
               Directory.CreateDirectory(dir);
           }
           // 该资产包是发布用于Windows平台的资源用的
   	    BuildPipeline.BuildAssetBundles(dir,
                                           BuildAssetBundleOptions.None,
                                           BuildTarget.StandaloneWindows64);
       }
   }
   ```

   这个脚本与一般的组件脚本不同，它是一个编辑器脚本。首先它 应当出现在编辑器专用文件夹中，其次它引用了命名空间 UnityEditor。而代码开头括号中的MenuItem特性，会修改Unity编辑 器的主菜单。

保存后切换到Unity，正确编译后，在主菜单中会多出一个Asset Bundles选项。

单击Asset Bundles选项后，就会在工程文件夹的Assets文件夹之 外创建一个AssetBundles新文件夹。但是没有设置哪些资产打入哪些 包，因此还没有实际效果。接下来设置每个资产所属的资产包。

选中Cube，会在编辑器右下角看到预览窗口，预览窗口下方有两 个菜单，这两个菜单都与资产包相关。单击左侧的按钮，选择New为资 产包命名，如命名为ab。然后确认prefab所属的资产包已经设置为ab资产包。

同样，分别选择另外3个预制体，也将它们所属的资产包设置为ab。但这里不需要设置图片和材质的资产包，设置或不设置并不影响结果。

有了工具脚本，设置好了资产包，准备工作就完成了。接着再单 击主菜单中的AssetBundles→Build AssetBundles，编辑器就会自动打包。

打包后在资源管理器的工程文件夹中找到AssetBundles文件夹 （在Assets文件夹外面），文件夹里可以看到两个无扩展名的文件， 其中ab就是指定的资产包，而`ab.manifest`则是资产的相关信息。

Unity默认将资产包的根目录放在Assets文件夹之外，侧面说明资产包已经可以独立存在，不再像普通资源那样需要被引擎管理，而可 以将它放在硬盘中任意位置。

**加载和使用资产包：**

之前使用预制体时只有两种方案，要么用公开变量直接引用预制体，要么用`Resources.Load`动态加载预制体，而现在有了第三种更灵活的方法——从资产包中加载资源。

新建脚本TestLoadAB，其内容如下：

```c#
using UnityEngine;
public class TestLoadAB : MonoBehaviour
{
    void Start()
    {
        // 从文件中加载到AssetBundles
        AssetBundle ab = AssetBundle.LoadFromFile("D:/AssetBundles/ab");
        // 分别加载4个预制体资源
        GameObject prefab1 = ab.LoadAsset<GameObject>("Cube");
        GameObject prefab2 = ab.LoadAsset<GameObject>("Sphere");
        GameObject prefab3 = ab.LoadAsset<GameObject>("icon1");
        GameObject prefab4 = ab.LoadAsset<GameObject>("icon2");
        // 以上4句话可以用下面一句话代替，它会查找所有预制体，返回所有预制体组成的数组
        //GameObject[] prefabs = ab.LoadAllAssets<GameObject>();

        Instantiate(prefab1, new Vector3(0, 0, 0), Quaternion.identity);
        Instantiate(prefab2, new Vector3(1, 0, 0), Quaternion.identity);
        Instantiate(prefab3, new Vector3(2, 0, 0), Quaternion.identity);
        Instantiate(prefab4, new Vector3(3, 0, 0), Quaternion.identity);
    }
}
```

以上代码从文件中加载到资产包ab，注意路径要与实际位置一致，否则会找不到文件。

获取到预制体之后，它们的使用方法就与普通方法没有区别了。

### 资源的常用路径

在上文的代码中，把路径写成了绝对路径。在实际游戏开发中不能使用绝对路径，因为每台计算机、每部手机的文件夹结构都可能有 所不同，所以必须采用间接的方式指定路径。而且，由于Windows、 Mac、Android和iOS等操作系统的文件夹结构都有所不同，因此应当使 用Unity提供的方法来间接指定文件夹。常用的系统路径主要有以下3种：

1. `Application.dataPath`，**数据路径**。它指的是**程序的数据所在的路径**，如在开发阶段，Assets就是数据文件夹。在移动平台上此路径用处不大。
2. `Application.streamingDataPath`，**原始数据路径**。它**对应的就是特殊文件夹`StreamingAssets`**，用于**存放不需要压缩处理的数据文件**。但**在移动端中，`StreamingAssets`文件夹也是只读文件夹，不能写 入数据。**
3. `Application.persistentDataPath`，**持久化数据路径**。这是一个**可读、可写的路径，所有游戏的存档、下载的资产包都应当放在此路径中。**

如果游戏需要发布到移动端，而且又需要保存数据，那么常用路径的作用就必须要了解。但是，对于商业项目来说还会遇到更多更复杂的问题，例如，安卓系统的可写文件夹分为主存储区和SD卡区两部 分，苹果系统的持久化数据文件夹会被iCloud自动备份。还有很多细节问题本文无法展开说明，实际使用时可查阅其他更详细的资料。

### 资产的依赖关系

无论是否设置图片和材质文件所属的资产包， 都不会影响打包和加载的效果。

为了确认这一点，可以删除Assets文件夹中的原始资源文件，以确认是否所有的资源都是从资产包中动态 获得的。

从表面上看，需要打资产包的资源都应该设置资产包，但实际上，很多没有设置资产包的资源也会进入资产包，这是因为Unity可以识别出资产包依赖哪些资源。

例如，立方体和球体预制体都需要材质资源，两个精灵prefab都需要图片，因此图片和材质会被一起放到资产包中。

如果所有的资产进入同一个资产包，那么每一个资产最多只存在一份（要么进入资产包，要么不进入资产包），这没什么需要考虑的。但实际上，一个游戏不可能只有一个资产包，很可能有许多个资产包，这时候再考虑依赖关系，会出现一个棘手的问题。

### 从网络加载资源



### 热更新

热更新的思想从本质来讲，要考虑一些问题。例如，一个完整的游戏最多可以有多大比例的资源通过网络加载？能否让尽可能多的资源通过网络加载？

通过**网络加载资源有很多好处**，不仅可以极大减小安装包的体积，而且有助于游戏的推广传播。更重要的是，以后游戏更新都不再需要重新安装，只要有网络，打开游戏后自动加载新版本的资源就可以了。

**哪些资源需要通过网络加载呢？**首先，理论上几乎全部资源都可以通过网络加载；其次，Unity脚本本身不支持动态加载。针对这两点有以下两个解决方案：

1. **过渡场景**

   最容易想到的是，要想减小安装包体积，应该在游戏中做一个最 简单、最基本的过渡场景。过渡场景本身需要的素材非常少（如只有 一个加载进度条），其作用也只有一个——联网下载所有必要的资产 包，等下载完成后再切换场景，正式启动游戏。如果采用这种设计， 游戏的安装包只需要包含Unity引擎本身的资源、加载程序的资源和过渡场景的资源就足够了，从而安装包的容量可以做到非常小。

2. **脚本的动态加载**

   脚本资源最好也能通过网络加载和更新。如果脚本不能更新，就 只能更新美术资源和数据文件，而绝大部分游戏逻辑都无法改动，旧版本中的程序bug也无法修复。 

   脚本动态加载涉及动态编译和执行的问题，属于很深入的技术问 题。现代脚本动态加载的思路分为以下两大类：

   **第一类思路，将脚本编译成动态链接库（DLL），然后把DLL当作资源打入资产包。使用脚本时，利用C#的反射机制，让DLL中的程序动态执行。** 

   优点：不需要改变原本的脚本编程方法，仅仅在打包 和加载时需要做一些额外的处理。也就是说，对开发者几乎不会带来额外的负担。

   致命的缺点：在iOS平台上，出于安全性的考虑，不允许利用反射加载网络代码，因此这种做法在iOS等安全性要求较高的操作系统中无法使用。

   **为什么反射机制存在安全隐患？**

   在iOS等平台上，应用程序安装包包含的代码已经通过了平台的 检测和审核，很大程度上降低了病毒或木马程序存在的可能性。

   利用C#反射机制加载的代码具有和常规代码相同的权限，如果 下载的动态链接库中存在恶意代码也会被执行。虽然游戏开发者并不会让用户下载恶意代码，但网络中的代码资源存在被恶意植入木马的可能性，如资源服务器被非法入侵、用户的网络被劫持等。

   **第二类思路，换一种全新的脚本框架，甚至可以换一种脚本的开 发语言。**

   现在流行的热更新框架中，采用Lua作为开发语言比较常见。 另外，也有采用C#语言的热更新框架，好处是不需要学习和使用另一 种新的编程语言。 这种思路是**在运行的环境中创建一个新的虚拟机，由虚拟机负责热更新脚本的运行。由于这些脚本只能调用有限的程序接口，而不会拥有过多权限，因此是相对安全的。**

   例子：

   ```c#
   AssetBundle ab = www.assetBundle;
   try
   {
       // 先把DLL以TextAsset方式取出来，再把纯数据（bytes）交给Assembly.Load方法动态加载
       Assembly aly = System.Reflection.Assembly.Load(((TextAsset)www.assetBundle.mainAsset).bytes);
   
       // 获取DLL下全部的类型
       foreach (var i in aly.GetTypes())
       {
           //添加组件到当前GameObject下面（演示用）
           Component c = this.gameObject.AddComponent(i);
       }
   }
   catch (Exception e)
   {
       Debug.Log("加载DLL出错");
       Debug.Log(e.Message);
   }
   ```

   ```lua
   Login = {}
   local this = Login
   require('Music')
   local ui
   local manager
   function this.Awake(object)
       manager = GameObject.Find('LuaManager')
       manager: AddComponent(typeof(AudioSource))
   
       coroutine.start(Music.PlaySound)
   
       print('object'..object.name)
       ui = object
   
       local startBtn = ui.transform:
       Find("StartBtn").gameObject
       UIEvent.AddButtonOnClick(startBtn, StartOnClick)
   end
   function StartOnClick()
       SceneManagement.SceneManager.LoadScene("Jump")
   end
   ```

3. **版本资源列表**

   需要版本资源列表的原因是，每次版本更新都需要对本地资源和 远程服务器的资源进行版本比对。而且，如果用户的本地资源有一部分是新的，一部分是旧的，也需要某种机制保证快速、准确地更新旧的资源。

   版本更新首先要以版本号作为基础。客户端有一个版本号，如1.0 版，如果发现服务器端版本号是1.1版，则客户端就要下载1.1版的资 源到本地。最简单的思路是，在服务器上存放一个从1.0版到1.1版有 变化的文件列表，客户端根据该列表逐个更新资源即可，更新完成后 版本号变为1.1版。

   这种思路可以达到效果，但不够灵活。更好的思路如下：

   1. 服务器端的每一个资源文件都计算一次MD5码，并将结果保 存在资源列表里。
   2. 本地的每一个文件也要计算一次MD5码，为避免重复计算， 可以在计算一次后就保存到本地的列表文件中。 
   3. 升级版本时，对比服务器端每个文件的MD5码和本地文件的 MD5码，只下载MD5码不一致的文件。
   4. 下载完成后可以重新计算MD5码，这样可以顺便检验在下载 过程中数据传输是否出错。 
   5. 确保资源一致以后可以修改本地版本号，避免重复检查。

**MD5码**是一种数据加密算法，它会遍历文件中的所有数据，并将所有的数据以一种特殊算法合并，形成一个128比特（16字节）的数 字。

相同数据计算出的MD5码也相同，如果文件中有任何一个比特变 化，则生成的MD5码都会完全不同。现实中随意修改一个文件，但 MD5码不变的概率接近0。这里借用的正是MD5码的这一性质。

虽然MD5码是一种加密算法，但它的碰撞算法已经被山东大学的王小云教授破解，因此现在不再作为加密算法使用。由于MD5码具有 算法简单、计算快的优点，因此作为文件一致性比较算法非常合适。

市面上出现了多种功能齐全的热更新框架，主要有以下功能：

1. 提供执行热更新代码的虚拟机环境。
2. 把引擎提供的类型、方法和属性导出，让开发者可以在热更新 代码中访问引擎功能。
3. 将开发者编写的Unity脚本接口导出，让热更新代码可以调用C# 中的类型、方法和属性。
4. 提供一些方法，让Unity脚本可以使用热更新代码中的类型、函 数和属性，打通两套代码之间的桥梁。

一般来说，由于运行原理不同，动态加载的代码的执行效率会低于原生脚本。

如果确实发现因动态脚本代码发生性能热点，可以将运 算压力较大的部分用原生脚本编写，并封装成函数，然后让动态加载的代码调用该函数。