# Unity脚本与资源管理

游戏中的资源管理包含了多重含义，如静态资源的组织方式，资源的打包和压缩，资源何时加载到内存、何时释放都属于资源管理的范畴。

## Unity项目的文件夹结构



## META文件



## 动态加载和释放资源



## 资产包与热更新



### 资产包（Asset Bundle）



### 资源的常用路径



### 资产的依赖关系



### 从网络加载资源



### 热更新

热更新的思想从本质来讲，要考虑一些问题。例如，一个完整的游戏最多可以有多大比例的资源通过网络加载？能否让尽可能多的资源通过网络加载？

通过**网络加载资源有很多好处**，不仅可以极大减小安装包的体积，而且有助于游戏的推广传播。更重要的是，以后游戏更新都不再需要重新安装，只要有网络，打开游戏后自动加载新版本的资源就可以了。

**哪些资源需要通过网络加载呢？**首先，理论上几乎全部资源都可以通过网络加载；其次，Unity脚本本身不支持动态加载。针对这两点有以下两个解决方案：

1. **过渡场景**

   最容易想到的是，要想减小安装包体积，应该在游戏中做一个最 简单、最基本的过渡场景。过渡场景本身需要的素材非常少（如只有 一个加载进度条），其作用也只有一个——联网下载所有必要的资产 包，等下载完成后再切换场景，正式启动游戏。如果采用这种设计， 游戏的安装包只需要包含Unity引擎本身的资源、加载程序的资源和过渡场景的资源就足够了，从而安装包的容量可以做到非常小。

2. **脚本的动态加载**

   脚本资源最好也能通过网络加载和更新。如果脚本不能更新，就 只能更新美术资源和数据文件，而绝大部分游戏逻辑都无法改动，旧版本中的程序bug也无法修复。 

   脚本动态加载涉及动态编译和执行的问题，属于很深入的技术问 题。现代脚本动态加载的思路分为以下两大类：

   **第一类思路，将脚本编译成动态链接库（DLL），然后把DLL当作资源打入资产包。使用脚本时，利用C#的反射机制，让DLL中的程序动态执行。** 

   优点：不需要改变原本的脚本编程方法，仅仅在打包 和加载时需要做一些额外的处理。也就是说，对开发者几乎不会带来额外的负担。

   致命的缺点：在iOS平台上，出于安全性的考虑，不允许利用反射加载网络代码，因此这种做法在iOS等安全性要求较高的操作系统中无法使用。

   **为什么反射机制存在安全隐患？**

   在iOS等平台上，应用程序安装包包含的代码已经通过了平台的 检测和审核，很大程度上降低了病毒或木马程序存在的可能性。

   利用C#反射机制加载的代码具有和常规代码相同的权限，如果 下载的动态链接库中存在恶意代码也会被执行。虽然游戏开发者并不会让用户下载恶意代码，但网络中的代码资源存在被恶意植入木马的可能性，如资源服务器被非法入侵、用户的网络被劫持等。

   **第二类思路，换一种全新的脚本框架，甚至可以换一种脚本的开 发语言。**

   现在流行的热更新框架中，采用Lua作为开发语言比较常见。 另外，也有采用C#语言的热更新框架，好处是不需要学习和使用另一 种新的编程语言。 这种思路是**在运行的环境中创建一个新的虚拟机，由虚拟机负责热更新脚本的运行。由于这些脚本只能调用有限的程序接口，而不会拥有过多权限，因此是相对安全的。**

   例子：

   ```c#
   AssetBundle ab = www.assetBundle;
   try
   {
       // 先把DLL以TextAsset方式取出来，再把纯数据（bytes）交给Assembly.Load方法动态加载
       Assembly aly = System.Reflection.Assembly.Load(((TextAsset)www.assetBundle.mainAsset).bytes);
   
       // 获取DLL下全部的类型
       foreach (var i in aly.GetTypes())
       {
           //添加组件到当前GameObject下面（演示用）
           Component c = this.gameObject.AddComponent(i);
       }
   }
   catch (Exception e)
   {
       Debug.Log("加载DLL出错");
       Debug.Log(e.Message);
   }
   ```

   ```lua
   Login = {}
   local this = Login
   require('Music')
   local ui
   local manager
   function this.Awake(object)
       manager = GameObject.Find('LuaManager')
       manager: AddComponent(typeof(AudioSource))
   
       coroutine.start(Music.PlaySound)
   
       print('object'..object.name)
       ui = object
   
       local startBtn = ui.transform:
       Find("StartBtn").gameObject
       UIEvent.AddButtonOnClick(startBtn, StartOnClick)
   end
   function StartOnClick()
       SceneManagement.SceneManager.LoadScene("Jump")
   end
   ```

3. **版本资源列表**

   需要版本资源列表的原因是，每次版本更新都需要对本地资源和 远程服务器的资源进行版本比对。而且，如果用户的本地资源有一部分是新的，一部分是旧的，也需要某种机制保证快速、准确地更新旧的资源。

   版本更新首先要以版本号作为基础。客户端有一个版本号，如1.0 版，如果发现服务器端版本号是1.1版，则客户端就要下载1.1版的资 源到本地。最简单的思路是，在服务器上存放一个从1.0版到1.1版有 变化的文件列表，客户端根据该列表逐个更新资源即可，更新完成后 版本号变为1.1版。

   这种思路可以达到效果，但不够灵活。更好的思路如下：

   1. 服务器端的每一个资源文件都计算一次MD5码，并将结果保 存在资源列表里。
   2. 本地的每一个文件也要计算一次MD5码，为避免重复计算， 可以在计算一次后就保存到本地的列表文件中。 
   3. 升级版本时，对比服务器端每个文件的MD5码和本地文件的 MD5码，只下载MD5码不一致的文件。
   4. 下载完成后可以重新计算MD5码，这样可以顺便检验在下载 过程中数据传输是否出错。 
   5. 确保资源一致以后可以修改本地版本号，避免重复检查。

**MD5码**是一种数据加密算法，它会遍历文件中的所有数据，并将所有的数据以一种特殊算法合并，形成一个128比特（16字节）的数 字。

相同数据计算出的MD5码也相同，如果文件中有任何一个比特变 化，则生成的MD5码都会完全不同。现实中随意修改一个文件，但 MD5码不变的概率接近0。这里借用的正是MD5码的这一性质。

虽然MD5码是一种加密算法，但它的碰撞算法已经被山东大学的王小云教授破解，因此现在不再作为加密算法使用。由于MD5码具有 算法简单、计算快的优点，因此作为文件一致性比较算法非常合适。

市面上出现了多种功能齐全的热更新框架，主要有以下功能：

1. 提供执行热更新代码的虚拟机环境。
2. 把引擎提供的类型、方法和属性导出，让开发者可以在热更新 代码中访问引擎功能。
3. 将开发者编写的Unity脚本接口导出，让热更新代码可以调用C# 中的类型、方法和属性。
4. 提供一些方法，让Unity脚本可以使用热更新代码中的类型、函 数和属性，打通两套代码之间的桥梁。

一般来说，由于运行原理不同，动态加载的代码的执行效率会低于原生脚本。

如果确实发现因动态脚本代码发生性能热点，可以将运 算压力较大的部分用原生脚本编写，并封装成函数，然后让动态加载的代码调用该函数。