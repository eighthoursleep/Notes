# Unity图形性能基础

## 减少CPU开销

渲染在CPU上花费时间最多的部分是发送渲染指令到GPU.

渲染指令包括：

1. drawcall（绘制几何图形命令）；

2. 绘制前修改GPU设置命令。

注意以下问题：

1. 减少要渲染的物体数量。
   1. 减少一个场景里所有物体的数量。比如可以用天空盒子制造几何距离效果。
   2. 进行更严格的筛选，让unity可以绘制更少的物体。考虑使用遮挡剔除，以防止unity绘制被挡住的物体。降低摄像机的远处裁剪面，让更多远处的物体不再视锥范围内。如果要达到更细腻的细节效果，考虑使用多个分层并在摄像机设置layerculldistance（每层的消隐距离）
2. 减少每个物体的渲染时间。
   1. 使用光照投影来烘焙（提前计算）光照和阴影。这个做法会增加build时间，运行时内存开销和存储空间，但可以提高运行时性能。
   2. 如果用的是前向渲染（一种渲染方式，根据光照的效果，通过多个管线渲染一个或多个物体），减少逐像素实时光照的个数。
   3. 实时阴影属于资源密集型渲染，请节省着用，用在刀刃上。
   4. 如果项目中使用了反射检测，请确保优化使用方式。
3. 减少渲染工作量，即Unity必须准备和发送的渲染命令，常见的是减少批处理的批数。

以上方式也会减少GPU的工作量，例如减少每一帧的总物体数，可以同时降低CPU和GPU的工作负担。

## 减少GPU开销

GPU渲染一帧失败有以下3个主要原因：

1. 如果一个功能受限于填充率，说明GPU在一帧里正尝试绘制更多它没法搞定的像素。如果这种情况发生了，有以下选项：
   1. 查明并减少功能里的重复绘制。最常见的导致重复绘制的原因是透明物体的重叠，比如UI，粒子特效和sprite。在Unity编辑器里，使用Overdraw Draw mode来定位问题区域。
   2. 减少片元着色器的执行消耗。
   3. 如果你用的是Unity内置着色器，从Mobile和Unlit类型中选一个。他们也可以用在非移动平台上，他们只不过是更复杂的着色器的简版或者说接近版。
   4. 使用动态分辨率。这是Unity的一项特色功能，可以让你动态改变每一个渲染目标的缩放。
2. 如果功能受限于内存带宽，GPU会读写更多它没法搞定的数据到申请的显存里。这常常表示有太多的贴图或者贴图太大。面对这种情况，有以下选项：
   1. 使用mipmap。给那些在运行时到镜头的距离会变化的材质使用mipmap。（例如，绝大多数在3D场景里使用到的贴图）。这会增加内存开销和存储空间，但卡伊提高运行时的显卡性能。
   2. 使用合适的压缩格式来降低贴图的内存占用。这可以让载入时间更快，提高GPU的渲染性能。压缩贴图仅仅使用了未压缩贴图的内存带宽的一小部分。

3. 如果功能受限与顶点处理，意味着GPU在一帧里正处理它搞不定的过多节点。应对这种情况有以下选项：
   1. 减少顶点着色器的执行消耗。
   2. 优化几何结构，不要没有必要的三角形，要让UV映射的缝合处、硬边毛刺的数量越少越好。

## 减少渲染频率

有时候这么做会有益于降低渲染帧率。这不会减少CPU或GPU在渲染一帧时的消耗，不会减少除了渲染以外的操作的频率。

你可以降低部分功能的帧率或者整个项目的帧率。降低帧率可以防止非必要的电源消耗，防止电池短寿，防止设备升温导致CPU降频。特别是应用在手持设备上。

如果分析显示渲染消耗的资源占比过大，要思考你做的功能的哪部分会受益。常见的例子包括暂停菜单，回合制等需要等待输入的游戏，以及大部分内容是静态的的功能，比如自动UI。

为了防止输入延迟，你可以在这需要的时间段内临时增加帧率，让游戏响应及时。

控制调节帧率，请使用OnDemandRendering API.



## Forward rendering path



## 阴影性能问题



## 反射检测性能问题



## 优化DrawCalls



## Unity的Overdraw Draw mode



## Shader性能问题



## 创建模型时要考虑的性能优化问题

