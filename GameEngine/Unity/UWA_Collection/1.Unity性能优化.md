# 性能优化

原文链接：
http://blog.uwa4d.com/archives/optimzation_cpu.html
http://blog.uwa4d.com/archives/optimzation_memory_1.html
http://blog.uwa4d.com/archives/optimzation_memory_2.html

[TOC]

对游戏的性能优化主要围绕3大方面：CPU、GPU、内存

## 一、CPU

cpu开销归结为2类：
1. 引擎性能模块
   1. 渲染模块（Top3）
   2. 动画模块
   3. 物理模块
   4. UI模块（Top3）
   5. 粒子模块
   6. 加载模块（Top3）
   7. GC调用
2. 自身代码性能模块

### 1.1 渲染模块

任何游戏中最消耗cpu性能的引擎模块，因为几乎所有游戏都离不开场景、物体和特效的渲染。

两方面入手：
1. 降低drawcall
2. 简化资源

一般地，dc越高，渲染cpu开销越大。

原因着手：底层驱动和GPU渲染流程

降DC的方法：
减少所渲染的物体的材质种类，通过批处理减少材质数量。（看官方文档批处理原理）

并非DC越小越好。这是因为，决定渲染模块性能的除了Draw Call之外，还有用于传输渲染数据的总线带宽。当我们使用Draw Call Batching将同种材质的网格模型拼合在一起时，可能会造成同一时间需要传输的数据（Texture、VB/IB等）大大增加，以至于造成带宽“堵塞”，在资源无法及时传输过去的情况下，GPU只能等待，从而反倒降低了游戏的运行帧率。

Draw Call和总线带宽是天平的两端，我们需要做的是尽可能维持天平的平衡，任何一边过高或过低，对性能来说都是无益的。


简化资源：过量的网格资源、不合规的纹理资源（每帧渲染的三角形面片数、网格和纹理资源的具体使用情况）

渲染模块在CPU方面的其他优化方法：LOD、Occlusion Culling、Culling Distance

### 1.2 UI模块

### 1.3 加载模块

加载模块的性能开销比较集中，主要出现于场景切换处，且CPU占用峰值均较高。

场景切换时，其性能开销的主要体现形式。对于目前的Unity版本而言，场景切换时的主要性能开销主要体现在2个方面：
1. 前一场景的场景卸载
2. 下一场景的场景加载。

场景卸载：

对于Unity引擎而言，场景卸载一般是由引擎自动完成的，即当我们调用类似Application.LoadLevel的API时，引擎即会开始对上一场景进行处理，其性能开销主要被以下几个部分占据：
1. Destroy
 引擎在切换场景时会收集未标识成“DontDestoryOnLoad”的GameObject及其Component，然后进行Destroy。同时，代码中的OnDestory被触发执行，这里的性能开销主要取决于OnDestroy回调函数中的代码逻辑。
2. Resources.UnloadUnusedAssets
 一般情况下，场景切换过程中，该API会被调用两次，一次为引擎在切换场景时自动调用，另一次则为用户手动调用（一般出现在场景加载后，用户调用它来确保上一场景的资源被卸载干净）。在我们测评过的大量项目中，该API的CPU开销主要集中在500ms~3000ms之间。其耗时开销主要取决于场景中Asset和Object的数量，数量越多，则耗时越慢。

场景加载：
可细分成以下几个部分：
1. 资源加载：
 资源加载几乎占据了整个加载过程的90%时间以上，其加载效率主要取决于资源的加载方式（Resource.Load或AssetBundle加载）、加载量（纹理、网格、材质等资源数据的大小）和资源格式（纹理格式、音频格式等）等等。不同的加载方式、不同的资源格式，其加载效率可谓千差万别。
2. Instantiate实例化
 在场景加载过程中，往往伴随着大量的Instantiate实例化操作，比如UI界面实例化、角色/怪物实例化、场景建筑实例化等等。在Instantiate实例化时，引擎底层会查看其相关的资源是否已经被加载，如果没有，则会先加载其相关资源，再进行实例化，这其实是大家遇到的大多数“Instantiate耗时问题”的根本原因，提倡资源依赖关系打包并进行预加载，从而来缓解Instantiate实例化时的压力。
 Instantiate实例化的性能开销还体现在脚本代码的序列化上，如果脚本中需要序列化的信息很多，则Instantiate实例化时的时间亦会很长。最直接的例子就是NGUI，其代码中存在很多SerializedField标识，从而在实例化时带来了较多的代码序列化开销。

### 1.4 代码效率：

逻辑代码在一个较为复杂的游戏项目中往往占据较大的性能开销。这种情况在MOBA、ARPG、MMORPG等游戏类型中非常常见。

在项目优化过程中，我们经常会想知道，到底是哪些函数占据了大量的CPU开销。同时，绝大多数的项目中其性能开销都遵循着“二八原则”，即80%的性能开销都集中在20%的函数上。

高CPU占用函数：
表格

## 二、内存

三大部分：
1. 资源内存占用
2. 引擎模块自身内存占用
3. 托管堆内存占用

### 2.1 资源内存占用

#### 2.1.1 纹理

##### 2.1.1.1 纹理格式

##### 2.1.1.2 纹理尺寸

##### 2.1.1.3 Mipmap功能

##### 2.1.1.4 Read&Write

#### 2.1.2 网格

##### 2.1.2.1 Normal、Color、Tangent

### 2.2 引擎模块自身占用

### 2.3 托管堆内存占用

### 2.4 内存泄漏

#### 2.4.1 检查资源的使用情况，特别是纹理、网格等资源的使用

#### 2.4.2 通过Profiler来检查WebStream或SerializedFile的使用情况

#### 2.4.3 通过Android PSS/iOS Instrument反馈的App线程内存来查看

### 2.5 Mono无效堆内存开销

### 2.6 资源冗余

#### 2.6.1 AssetBundle打包机制出现问题

#### 2.6.2 资源的实例化所致