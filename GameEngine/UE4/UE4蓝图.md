# UE4蓝图

UE4蓝图是一种可视化玩法脚本语言，它基于将节点从左连到右的点图机制。

蓝图可以制作成品游戏或者简单/复杂的游戏机制，比如控制门的关闭开启。

蓝图的最大优势是不需要程序员来搭建逻辑关系。



## 3种蓝图

除了关卡蓝图，所有蓝图类型都是在内容浏览器里创建。

### 关卡蓝图

“关卡（Level）”是指UE种制成的游戏场景。

关卡蓝图用于制作当前游戏场景的程序。

可以说，再UE中进行的编程就是在创建关卡蓝图。

关卡蓝图没法手动创建，是包含在关卡里的。

关卡蓝图在关卡被加载后可以访问。

你可以引用场景里的任何资源并且与之互动。

如果你在关卡蓝图里引用了一个蓝图类，你可以访问这个类的所有公共变量和公共函数。

关卡蓝图的优点是可以轻松访问关卡里的actor，直接引用无需转换类型。这有助于在创建一些不在关卡里触发的事件或调用的函数。

要创建关卡中的资源，可以先选中要访问的资源，然后在关卡蓝图里右键，选择`Create a Reference to XXX`。

### 游戏模式

游戏模式（GameMode）是与制作中的游戏整体相关的设置、动作。

### 类蓝图

类（Class）是集中处理几个相关功能及数据的小型程序。创建类会使结构整体一目了然。

蓝图类使用最普遍，因为它自带玩法机制，而且可以在多个关卡里复用。

蓝图类继承自原始C++类。

创建蓝图类的方法：右键内容浏览器，在“新建基础资源”下边选择蓝图类。

## 图表编辑器的基本操作

显示位置的移动（鼠标右键拖拽）

显示的缩放（鼠标滚轮）

节点的创建、选择、移动、删除、复制、粘贴、连接、断开连接（右击连接项目中的一方，在弹出的菜单中选择“断开到xxx的连接”命令）

程序运行（编译、保存、播放）

## 节点

在UE中，一个蓝图节点可以代表事件、流程控制操作、函数、变量等。一个节点的源码可以很简单也可以很复杂。

开发者可以到蓝图编辑面板，用C++写自己的节点。

### 节点的构成

基本上所有的节点都由以下3部分构成：

- 标题：在节点的上方显示，会根据节点的**类型**而显示不同的**颜色**。

- 输入引脚：显示在节点左侧，用于**从其他节点接收数据**。

- 输出引脚：显示在节点右侧，用于**传递数据到其他节点**。

在蓝图中，处理操作是按“从左至右”的顺序执行。

排布节点时，将最先执行的放在最左边，然后依次向右侧排列，比较容易连接。

### 重要的3种节点

#### 事件节点（event node）

当用户操作或者游戏场景中发生了某件事时，会触发事件，类似于一种信号。

事件节点的标题显示为**红色**。

例子：事件BeginPlay节点。

#### 执行节点

特征：

- 左右两侧都有白色的五角形引脚
- 蓝色标题

例子：PrintString节点。

#### 读取节点

特征：

- 没有设定处理顺序的白色五角形引脚，即不能从事件连接到该节点。
- 绿色标题

作用：向其他结点传递必要的信息。

### 展开节点的信息显示

例如PrintString节点，点击下方的三角形可以展开/隐藏其他项目。展开我们可以看到多了以下项目：

Print to Screen：是否将文本打印到画面上；

Print to Log：是否将文本记录在日志或记录执行状况等的文件中；

Text Color：文本颜色。

### 关于创建节点的菜单

#### 选项的显示顺序

如果在关卡编辑器上选择了3D空间中配置的部件，那么在弹出的创建节点菜单上方会显示经常使用的、与该部件有关的选项，同时其他选项会顺移到其下方。

#### 情境关联

注意菜单右上方的“情境关联”复选框。

其功能时显示与当前状态关联度高的节点。

除此之外，如果勾选了，经常使用的东西或者重要的东西会转化为中文显示，如果不勾选，则全部以英文显示。

情景关联是ON还是OFF，显示的内容是不同的，如果在检索时找不到目标选项，可以看一下情境关联是否打开了。

### 节点注释和注释组

右击节点，显示的菜单最下方有“节点注释”项。在节点注释项输入文本内容可以立即显示。

选中要注释的多个节点后，再任意节点上右击，再弹出的菜单选择“从选中项中创建注释”，可以将这些节点全部包围起来，然后在注释标题框输入文本内容即可。

## 变量与计算

### 值的类型

文本、字符串（Text、String）

整型、浮点型（Int、Float）

布尔型（Bool）

常用的创建值的节点：`Make Literal String`、`Make Literal Int`。

### 数学表达式节点



### 蓝图变量

变量的细节的几个项：

**可编辑**：表示是否公开编辑该变量，为了在公开的蓝图实例上能够处理变量。

**工具提示**：当鼠标悬停到该变量上时，显示该变量的工具提示信息。

**在生成时显示**：设置生成此蓝图时，是否让此变量显示为引脚。

**私有**：限制所有外部访问的属性。

**显示到Matinee**：控制这个变量是否要暴露给Matinee以进行修改。

**分类**：指定变量的类别，方便整理。

**复制**：规定是否应该通过网络复制这个变量。

## 流程控制

### 分支

分支节点（Branch）:2选1

开关节点（Switch）：多选1

例如：`Switch On String`节点、`Switch On Int`节点

### 循环

#### ForLoop循环

输入项：

- Exec输入项：位于最上方的白色五角形，用于连接执行处理的顺序。
- First Index：为计数器设置的初始值。
- Last Index：计数器的结束值。当达Index到该值后，执行完循环处理后直接进入之后的处理中。

输出项：

- Loop Body：用于连接循环所执行的处理。多次执行连接到此处的处理。
- Index：取出当前计数器的值。想知道是第几次循环时使用。
- Completed：连接循环完成后的处理。循环结束后，进入连接到此处的处理。

#### ForEachLoop循环

输入：

- Exec输入项：连接执行处理的顺序。
- Array：连接要处理的数组

输出：

- Loop Body：将循环处理的内容连接至此以创建处理。
- Array Element：在ForEachLoop中将以顺序从数组中取出值，所取出的值从此处获得。
- Array Index：可获得取出值的Index编号。
- Completed：数组完成后，用于连接至之后的处理。

#### WhileLoop条件循环

输入：

- Condition：检查循环，每次循环都会检查Condition是否为真，为真则继续执行循环，为假则退出循环。

输出：

- Loop Body：用于连接循环所执行的处理。Condition为真时执行。
- Completed：用于连接循环结束后进行的处理。Condition为j假时执行。

### 程序结构化

#### 合并节点

将相连的多个节点选中，然后在其中一个节点右键，选择“合并节点（Collapse Nodes）”。

合并的节点在“我的蓝图”选项卡中的“事件图表（EventGraph）”处。

双击进合并的节点可以看到被合并的节点，左边起始点是Input，右边结束点是Output。

要拆分合并的节点，在合并节点右键选择“拆分节点（Expand Node）”。

合并节点可以嵌套。

#### 宏与函数

通过“宏”与“函数”可以将执行某个处理的节点集中到一个节点中，并可随时随地对其进行使用。

##### 宏

宏用于创建要执行的某个处理。可具备输入项和输出项，但却不包括exec输入输出项。可在构建一些小处理时使用，比如接受某个值并进行处理，或将处理的结果传递到其他节点。

##### 函数

函数与宏一样，预备有输入输出项，并利用它们进行处理。与宏不同的时，函数具有exec输入输出项。按顺序进行处理时，可将该函数连接至接下来要处理的处理中。

### 事件

事件就是根据各种各样的操作或者程序的状态而产生的一种信号。

在蓝图中，程序是通过“事件”的发生而调用的。创建程序后，如果不与事件连接，那么它是完全无法运行的。即使连接了事件，如果事件不发生，程序也是不能运行的。

#### 自定义事件



#### 带Break的Loop

ForLoopWithBreak、ForEachLoopWithBreak

#### 触发器（FlipFlop）

如果准备了多个事件要进行处理时，就会更多地使用到按需进行的分支处理了。

使用最多的一个节点就是“**触发器（FlipFlop）**”，**每次执行触发器时都可以交替调用两个分支**。例如有A、B两个处理，第1次调用A，第2次调用B，第3次调用A，第4次调用B，... 像这样轮番进行调用。

#### 序列

序列（Sequence）可以**依次调用一系列处理**。

## Actor的基本操作

### Transform

场景中的actor的细节面板的Transform里有一个Mobility，将其设为”Mov“，如果设为”Stat“，即使使用程序也不能移动这个actor。

打开关卡蓝图，在场景中选中一个actor，回到关卡蓝图编辑器里右键，就可以看到菜单里展示的关于对该actor的操作。需要注意的是，如果菜单中”情境关联“复选框没有勾选的话，这个功能不会显示。

如果没有在场景中选择一个actor，则表示关卡蓝图”不打算操作Actor“，就不会出现相关的菜单。

### Tick事件

`Begin Play`事件只在程序启动时执行一次，在操作actor时，可能需要经常检查actor的状态，或者给actor增加修改。

这时需要用到`Tick`事件，`Tick`事件用于显示所有帧都发生的事件。

`Tick`是切换显示每一帧时发生的事件。游戏的运行，伴随帧的更新，会进行以下流程的处理：

1. 更新显示的事件发生；
2. 运行`Tick`事件；
3. 以已更新的关卡为基础，渲染显示；
4. 在画面上显示生成的形象。

事件`Tick`的输出项有`Delta Second`，这个用于显示上一个Tick呼出后，经过多少时间显示。

常用的对actor的操作：

`AddActorLocalRotation`、`AddActorLocalOffset`、`AddActorLocalTransform`、

`AddActorWorldRotation`、`AddActorWorldOffset`、`AddActorWorldTransform`

**注意**

`Tick`事件并非每过规定的时间段触发一次，而是根据每个设备来调整触发，在速度快的设备上就能以更短的时间间隔触发，在速度慢的设备上，以长的时间间隔触发。

如果移动物体是用`Tick`规定距离，那么需要用`Delta Seconds`来修复在设备越好移动越快的问题。

程序可以设置为，在规定移动距离时，作为移动距离的数值与`Delta Seconds`相乘。在灵敏快速的设备上，触发间隔短，所以DeltaSeconds小，反之亦然。这样处理，在快速设备上移动短，在慢速设备上移动长，导致平均一定时间内的移动距离，与设备优劣无关，保持基本一致。

### 键盘移动

#### 输入事件

`IsInputKeyDown`

#### 为什么播放游戏后要单击视口？

因为键鼠的输入由一个控制板来接收，如果不单击运行场景的视口，按键输入等事件不能顺利进行。

在关卡编辑器中，显示了很多控制板，分别进行细节值的设置等。如果只是按键，系统不知道”输入到哪里“。因此需要单击输入控制板（有时是其中的输入区域等），事先指定”输入到这里“。

#### 如何连续移动？

方法有很多种，先介绍以下这个：

设置一个关卡蓝图变量（vector类型）`vec`;

输入事件的按下连接设置`vec`，设置每次按下的值；

输入事件的抬起连接设置`vec`，值全部设为0；

`Tick`事件连接`AddActorLocalOffset`，target连接要移动的actor的引用。

`Tick`事件的`Delta Seconds`与`vec`相乘，再乘100.0，再把结果传给`AddActorLocalOffset`节点的detaLocation。

### 鼠标输入

#### 鼠标X事件、鼠标Y事件

当鼠标光标横向或纵向移动时，会触发是鼠标X或鼠标Y事件。只要鼠标在移动过程中，就一直持续发生这些事件。

在这俩事件节点中，都有`Axis Value`输出项。它用于读取从上次该事件出现到当前事件之间的鼠标移动量。测出这个值就能知道“鼠标移动了多少”。

## 材质的编程

材质时“二维绘图程序”。

所谓**蓝图**，是将UE中所准备的各种各样的功能以视觉形式进行显示、连接并创建处理的**一种结构**。

材质用于定义Actor的表面处理，通过使用蓝图定义，可以完成复杂的实时变化的材质。

材质是一个通用的部件，并不是放置于关卡中的actor等的附属品，是在其他项目中也可以直接使用的独立部件，因此以文件的形式创建。

### 材质蓝图

材质蓝图中的节点，不同于关卡蓝图中所预备的节点。

材质蓝图中的节点没有exec项。

材质中预备的节点是一些只能实现“值的交互”的节点，不存在那种通过连接exec输入输出项能够创建处理流程的节点。

蓝图编辑器中默认只预备一个节点，标题为材质名称。该节点被称为“最终材质节点”，汇总应用于材质中的信息，以连接该节点的信息为基础，描画材质。即，“材质的创建”指“为最终材质输入节点接入什么样的信息”。

#### 基础颜色（Base Color）

可以使用`Constant3Vector`、`Constant4Vector`节点新建常量为Base Color赋值。

#### 贴图

所谓贴图就是一个图像文件，将表面的花纹或凹凸及光的反射这些以位图图像进行展现。

将贴图（png图）拖到材质蓝图里，生成一个**“TextureSample”节点**，这就是**贴图节点**。

贴图节点有4分输出项，最上方的项目可以直接取出贴图的图片，下方的红绿蓝三项，只分别从贴图中取出RGB的各饱和度信息。

TextureSample节点的细节面板中显示有`Material Expression Texture Base`，`Texture`项中设置了贴图。

#### 金属（Metallic）

基础颜色下方的项目为”金属“，可使Actor具有金属的质感。

该金属质感以0~1.0之间的值来指定。

如果是想全部设为一样的值，就把实数的值（Constant）连接至金属项即可。

如果是想像基础颜色那样有浓有淡的话，也可以使用贴图来设置。

金属以实数为值，当它连接`constant3Value`时，使用的是第一个值（即红色R的值）。

#### 高光即“反射”（Specular）

constant

#### 粗糙度即表面的“粗糙”（Roughness）

constant

#### 自发光颜色即为发光体（Emissive Color）

constant3vector

#### 不透明度与Blend Mode

在最终材质输入节点的细节中将Material | Blend Mode的 默认**Opaque（不透明）**设置为**Translucent（透明）**。

这样我们就可以往最终材质输入节点的输入项Opacity传入值（0~1，透明~不透明）了。

### 材质参数化

什么是参数化？就是可以从外部变更它的值。

除了直接为Actor设置材质文件并运行外，还可以通过创建“材质实例”的方法来使用材质。

材质实例时基于材质创建的一种类似副本的内容，材质实例基本上原样继承了其源材质的设置，但并不是完全相同。在源材质中准备“参数”，然后对参数进行修改。

参数类似于变量，准备参数然后把它连接到材质的最终材质输入项后，后续就可以设置参数的值了。这就是“参数化”。

#### 参数变量

VectorParam节点和贴图的加减法运算

ScalarParam节点连接高光、粗糙度

在group里可以键入名称，作分组管理

#### 材质实例（Material Instance）

要操作参数化的值，需要在材质实例，材质实例可以在内容浏览器右键菜单里创建。

打开材质实例，在细节面板里设置Parent为刚才经过参数化的材质。这时可以看到刚才的参数组以及组下边自定义的参数。勾选后后可以进行调节数值，更改材质实例的显示效果。

如此一来，实现了从材质实例访问材质参数。

#### 材质参数集（Material Parameter Collection）

材质参数集可以在内容浏览器右键菜单里创建。

创建后打开，点击加号添加对应数量的scalar参数和vector参数，并做好命名。

将材质参数集拖拽到材质蓝图里，在细节里设置参数（从参数集里选），复制多个，做好设置，如果有计算报错，可能时向量长度不匹配可以使用AppendVector节点提升维度以匹配，最后材质参数集取代连接之前的参数变量。

**如何在关卡蓝图访问材质参数集？**

在关卡蓝图里右键，添加节点`SetVectorParameterValue`和`SetScalarParameterValue`，在输入项`Collection`处选择创建的材质参数集，在`Parameter Value`传入值。

#### 材质函数（Material Function）

材质参数是指在材质内使用的函数。与材质实例、材质参数集一样，以文件的形式在内容浏览器创建。

创建一个材质函数，打开进去，发现预备有一个“Output Result”节点，这个是函数的输出值，左边连接运算过程，右边是输出不用连。

将材质参数集拖拽进去形成节点，在细节面板设置参数名。

常用运算节点：

`Fmod`：除法运算求余数

`Divide`：除法，计算到小数点之后

`Constant`：数值节点

往材质中推拽入材质函数，连接上对应的属性输入项即可，比如计算粗糙度的函数，计算结果连接最终材质输入的“粗糙度”输入项。



## Actor物理

### 给静态网格体添加碰撞体

双击进入后，在上方菜单栏寻找Collision，点开点击“Add Sphere Simplified Collision”，然后再场景中选中物体，在细节面板|Physics勾选Simulate Physics。

### 移动物体

Add Force节点

### Actor碰撞

#### 勾选Hit Events

有碰撞就可以进行碰撞处理吗？事实上不是。所谓碰撞处理，是在碰撞时发生事件，并为该事件连接一个处理来完成的，需要事先对碰撞事件的发生进行设置。

选中场景中的actor，在细节面板的“Collision”项目下勾选Simulation Generates Hit Events。

该项用于设置碰撞事件的发生，勾选后该actor与其他actor发生碰撞时就可以发生事件了。

#### OnActorHit事件

选中场景中的actor，在关卡蓝图中右键| Collision | Add Event for ... | Add On Actor Hit，得到OnActorHit事件节点。

OnActorHit是选中的actor与其他actor接触时所发生的事件，并且事件在碰撞期间持续发生，分开后才不再发生。

该节点中除了exec外预备有4个输出项，各自的作用如下：

- `Self Actor`：传递碰撞自身actor
- `Other Actor`：传递碰撞对象
- `Normal Impulse`：表示碰撞力的值。传递Vector的值
- `Hit`：传递汇总有碰撞相关信息的结构体的值

#### 检查碰撞对象

新建`Get Display Name`节点，传入`OnActorHit`的`Other Actor`，然后将其`Return Value`打印。

#### 使用标签

标签时用于标注actor的一种名称，用于整理actor的种类。

在关卡内选中actor，在细节面板的Tags添加标签即可。

检测是否有tag：`Actor Has Tag`节点

#### 重叠事件

设置物体的重叠后，与对象actor碰撞不会弹开分离，而是重叠，触发重叠事件。

使用重叠功能可以实现“接触后执行某些处理”。

对发生重叠事件的两个actor，都要进行重叠事件的设置。

- 在关卡编辑器的物体的细节面板 | Collision勾选`Generate Overlap Events`以使重叠事件发生。

- 在下方Collision Presets：
  - 选择OverlapAll，表示可以和所有actor重叠。
  - 选择PhysicsActor，表示

`OnActorBeginOverlap`事件节点。

重叠事件的缺点：

- 仅在于actor接触或分离时发生一次。
- 要使用重叠事件，actor必定要显示出来。

#### 触发器Trigger

触发器用于指定发生碰撞事件的空间范围。

触发器是非可见的内容。

`OnActorStartOverlap`事件

`OnActorEndOverlap`事件

## 过场动画

“过场动画”是通过自动变更actor等的设置来实现移动。

### Sequence与蓝图Actor



## UI



### HUD

UE预备有平视显示器（HUD）。

HUD以空间蓝图的形式创建。

#### 控件蓝图（Widget Blueprint）

关卡蓝图`Begin Play` -> `Create Hud Widget Widget` -> `Add to Viewport`

#### 在关卡蓝图中使用HUD

蓝图变量创建变量并设置类型为对象控件类

#### 开关HUD显示

`Add to Viewport`节点、`Remove from Parent`节点

#### 控制光标的显示

`Get Player Controller`节点 -> `Show Mouse Cursor`节点

## 蓝图接口

蓝图接口是蓝图的一种特殊类型，分为函数和变量。

