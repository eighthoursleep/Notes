# UE4的引擎初始化

UE4的引擎初始化分为两个过程，预初始化、初始化。

其具体实现由FEngineLoop这个类来提供。在不同平台上，入口函数不同（比如Windows平台下是WinMain，Linux平台下是Main），不同的入口函数最后会调用同样的FEngineLoop种的函数，实现跨平台。

## 预初始化

预初始化过程和初始化过程最显著的区别在于预初始化带有CmdLine，即能够获得传入的命令行字符串。

这过程主要根据传入的命令行字符串来完成一系列的设置状态的工作，大致分为这几个设置内容：

1. 设置路径：当前程序路径，当前工作目录路径，游戏的工程路径。

2. 设置标准输出：设置GLog系统输出的设备，是输出到命令行还是何处。

   并且也初始化了一部分系统，包括：

   - 初始化游戏主线程GameThread，其实只是把当前线程设置为主线程。
   - 初始化随机数系统，否则同样的种子会产生出虽然随机但一模一样的随机序列。
   - 初始化TaskGraph任务系统，并按照当前平台的核心数量来设置TaskGraph的工作线程数量。同时也会启动一个专门的线程池，生成一堆线程，用于在需要的时候使用。也就是说虚幻引擎的线程数量远多于核心数量的。

   预初始化过程会判断引擎的启动模式，是以游戏模式启动还是服务器模式启动。

   完成这些之后，会调用LoadCoreModules。目前CoreModules指CoreUObject。具体为何CoreUObject需要这样额外的启动，会在分析UObject的时候进行分析。

   随后，所有PreInitModules会被启动起来。这些强大的模块是：引擎模块、渲染模块、动画蓝图、Slate渲染模块、Slate核心模块、贴图压缩模块和地形模块。

   当这些模块加载完毕后，AppInit函数会被调用，进入引擎正式的初始化阶段。

   ## 初始化

   进入初始化流程，所有被加载到内存的模块，如果有PostEngineInit函数的，都会被调用从而初始化。这一过程是借助IProjectManager完成。

   由于Init的过程被分摊到每个模块种，因此初始化的过程显得格外简洁。

   ## 主循环

   UE的主循环代码，可以被表述为以下这样：

   ```cpp
   While(!GIsRequestingExit)
   {
       EngineTick();
   }
   ```

   这也是按照标准的引擎架构来书写，至少游戏主线程是存在一个专门的引擎循环，即EngineTick。

   UE的渲染线程是独立更新的，不在我们的主循环分析的内容种。

   引擎的Tick按照以下顺序更新引擎种的各个状态：

   1. 更新控制台变量。这些控制台变量可以使用控制台直接设置。
   2. 请求渲染线程更新当前帧率文字。
   3. 更新当前应用程序的事件，即`App::DeltaTime`
   4. 更新内存分配器的状态。
   5. 请求内存分配器的状态。
   6. 请求渲染线程刷新当前的一些底层绘制资源。
   7. 等待Slate程序的输入状态捕获完成。
   8. 更新GEngine，调用`GEngine->Tick`。
   9. 假如现在又个视频正在播放，需要等待视频播放完。之所以在GEngine之后等待，是因为GEngine会调用用户的代码，此时用户有可能会请求播放一个视频。
   10. 更新SlateApplication。
   11. 更新RHI。
   12. 收集下一帧需要清理的UObject对象。

具体可以阅读LaunchEngineLoop中的内容。

在`GEngine->Tick`中到底做了什么?

从最正常的角度来说，`GEngine->Tick`最重要的任务是更新当前 World。无论是编辑器中正在编辑的那个World，还是说游戏模式下只有 一个的那个World。此时所有World中持有的Actor都会被得到更新。 

请注意，笔者并没有说UObject会得到更新，事实上有许多UObject根本没有Tick功能。

那么其他的Tick内容则是从时间分片的角度来看待很多任务。这个 的意思是说，很多任务可能无法在一次Tick中完成，否则会卡死游戏主 线程，带来极其不好的游戏体验，因此会分在多次Tick函数中完成。当 前Tick需要完成什么任务，则是在Tick中根据诸多的状态来决定的。

例如正在加载地图，则每次都Tick一下，加载一点点；正在动态载入地图 （StreamLevel），或是正在进行HotReload，这些都会被分在不同的Tick中，以一次载入一点点的方式完成。