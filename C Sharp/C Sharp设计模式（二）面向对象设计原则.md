---
title: C#设计模式（二）面向对象设计原则
date: 2020-07-03 20:22:31
tags: C Sharp
toc: true
categories: 设计模式
---

设计模式、基本要素、分类、面向对象设计原则

<!--more-->

# 一、设计模式

## 什么是设计模式？

**设计模式（Design Pattern）**是一套被反复使用，多数人知晓的，经过分类编目的，代码设计经验的总结。

设计模式是一种用于对软件系统中不断重现的设计问题的解决方案进行文档化的技术，是一种共享专家设计经验的技术。

**目的：**为了**可复用**代码，让代码**更容易被他人理解**，提高代码**可靠性（少出错）**。

设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定制的解决方案，该方案描述了对象和类之间的相互作用。

## 设计模式基本要素

模式名称、问题、目的、解决方案、效果、实例代码、相关设计模式等。

**四个关键要素：**

**模式名称**（Pattern Name）、**问题**（Problem）、**解决方案**（Solution）、**效果**（Consequences）

## 设计模式的分类

**根据目的分类**

**创建型**模式：
抽象工厂模式（Abstract Factory）、建造者模式（Builder）、工厂方法模式（Factory Method）、原型模式（Prototype）、**单例模式（Singleton）**

**结构型**模式：
适配器模式（Adapter）、桥接模式（Bridge）、组合模式（Composite）、装饰模式（Decorator）、外观模式（Facade）、享元模式（Flyweight）、代理模式（Proxy）

**行为型**模式：
职责链模式(Chain of Responsibility)、命令模式(Command)、解释器模式(Interpreter)、迭代器模式(Iterator)、中介者模式(Mediator)、备忘录模式(Memento)、**观察者模式(Observer)**、**状态模式(State)**、策略模式(Strategy)、模板方法模式(Template Method)、访问者模式(Visitor)

**根据范围分类**

根据范围，即模式主要处理类之间的关系还是处理对象之间的关系，可分为类模式、对象模式：

类模式：处理类和子类之间的关系，这个关系通过继承建立，在编译时就被确立下来，是一种静态关系。

对象模式：处理对象之间的关系，这些关系在运行时变化，更具动态性。

## 设计模式的优点



# 二、面向对象设计原则⭐

**可维护性(Maintainability)**：指软件能够被理解、改正、适应及扩展的难易程度。

**可复用性(Reusability)**：指软件能够被重复使用的难易程度。

面向对象设计的目标之一在于支持可维护性复用，一方面需要实现设计方案或者源代码的复用，另一方面要确保系统能够易于扩展和修改，具有良好的可维护性。

面向对象设计原则是为支持可维护性复用而诞生的指导性原则，非强制性原则。

每一个设计模式都符合一个或多个面向对象设计原则，面向对象设计原则是用于评价一个设计模式的使用效果的重要指标之一。

## 单一职责原则

单一职责原则是最简单的面向对象设计原则，用于控制类的粒度大小。

**单一职责原则**（Single Resposibility Principle，SRP）：一个对象应该只包含单一的职责，并且改职责被完整地封装在一个类中。对于一个类而言，应该仅有一个引起它变化的原因。

一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性越小。

当一个职责变化时，可能会影响其他职责的运作。将整个职责进行分离，将不同的职责封装在不同的类中。将不同的变化原因封装在不同的类中。单一职责原则时实现**高内聚、低耦合**的指导方针。

## 开闭原则

开闭原则时面向对象的可复用设计的第一块基石，时最重要的面向对象设计原则。

**开闭原则**（Open Close Principle，OCP）：软件实体应当对扩展开放，对修改关闭。

在开闭原则的定义中，软件实体可以时一个软件模块、一个由多个类组成的局部结构或一个独立的类。

开闭原则是指软件实体应尽量在不修改原有代码的情况下进行扩展。

抽象化是开闭原则的关键。

相对稳定的抽象层 + 灵活的具体层

对可变性封装原则（Principle of Encapsulation of Variation, EVP）：找到系统的可变因素并将其封装起来。

## 里氏代换原则

**里氏代换原则**（Liskov Substitution Principle，LSP）：所有引用基类的地方必须能够透明地使用其子类的对象。

在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。

在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型。

## 依赖倒转原则

**依赖倒转原则**（Dependence Inversion Principle，DIP）：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖细节，细节应该依赖于抽象。

要针对接口编程，不要这针对实现编程。

在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等。

在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中。

针对抽象层编程，将具体类的对象通过依赖注入（Dependency Injection，DI）的方式注入到其他对象。

构造注入

设值注入（Setter注入）

接口注入

## 接口隔离原则

**接口隔离原则**（Interface Segregation Principle，ISP）：客户端不应该依赖那些它们不需要的接口。

当一个接口太大时，需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。

每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。

“接口”定义（1）：一个类型所提供的所有方法特征集合。一个接口代表一个角色，每个角色都有它特定的一个接口，“角色隔离原则”。

“接口”定义（2）：狭义的特定语言的接口。接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口，每个接口中只包含一个客户端所需的方法，“定制服务”。

## 合成复用原则

**合成复用原则**（Composite Reuse Principle，CRP）：优先使用对象组合，而不是继承来达到复用的目的。

合成复用原则是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之称为新对象的一部分。

新对象通过委派调用已有对象的方法达到复用功能的目的。复用时要尽量使用组合/聚合关系（关联关系），少用继承（依赖关系）。

**继承复用**：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用）

**组合/聚合复用**：耦合度相对较低，有选择地调用成员对象的操作；可以在运行时动态进行，新对象可以动态地引用与成员对象相同的其他对象。（“黑箱”复用）

## 最少知识原则

又称迪米特法则，**最少知识原则**（Least Knowledge Principle，LKP）：每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。

最少知识原则要求一个软件应当尽可能少地与其他实体发生相互作用。

应用最少知识原则可降低系统固定耦合度，使类与类之间保持松散的耦合关系。

不要和“陌生人”说话（Don't talk to strangers.）

只与你的直接朋友通信（Talk only to your immediate friends.）

1. 当前对象本身（this）
2. 以参数形式传入到当前对象方法中的对象
3. 当前对象的成员对象
4. 如果当前对象的成员对象使一个集合，那么集合中的元素也都是朋友
5. 当前对象所创建的对象

任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。

在应用最少知识原则时，一个对象只能与直接朋友发生交互，不要和“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。

最少知识原则要求在设计系统时，应尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不应该发生任何直接的相互作用。

如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用。

通过引入一个合理的“第三者”来降低现有对象之间的耦合度。

**应用最少知识原则注意事项**：

1. 在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大影响。

2. 在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限。
3. 在对其他类的引用上，一个对象对其他对象的引用应当降到最低。