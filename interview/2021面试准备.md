# 为什么使用FairyGUI，有什么优点？

- 交互友好
- 有很多UI元件功能不需要代码编写，FGUI已经实现，大部分简单需求只需按照提供的API调用即可。

- 高性能（优化DrawCall）

## fgui的DrawCall优化策略?



## 对比UGUI



## 对比Laya自带的UI



## 可补充讲一下循环列表和虚拟列表的fgui实现原理





# UI切图规范？

大图，背景图使用jpg，为什么？为什么其他用png格式

没有花纹可以通过FGUI九宫格拉伸的图尽量切得很小

按实际功能实现过程中的临时需求索要切图

# 讲讲UI框架？



## 怎么分层管理UI?



## UI怎么减小DrawCall?



## 红点怎么做（思想）？



## 新手引导怎么做（思想）？





# 讲讲UI资源优化？

## UI切图资源分包

分为Loading包，主包，二级菜单包。（每个图集最大2048 * 2048，尽量减小图集的空白空间有的1024 * 1024）

jpg图片单独一个图集，背景图或者大且没有透明部分的图使用jpg。

**为什么要分包？**

其中在多个界面重复使用的切图尽量放在主包。

游戏启动的时候先加载Loading包，然后是主包，第一次点开二级菜单加载二级菜单的分包。

**为什么要使用jpg？**

jpg优点：

- 占用内存小，加载速度快
- 对多色彩表现较好

缺点：

- 不支持透明
- 压缩有损

png优点：

- png的压缩是无损压缩，能保证最不失真的情况下尽可能压缩图片大小。
- 支持透明效果（支持alpha通道）

缺点：

- 内存占用较大，会导致加载速度慢



## 图片压缩？

**为什么压缩？压缩到什么程度？**

减小打包的大小，加快加载速度，压缩到尽量不失真的情况下。

# Laya底层怎么读JSON表？



# Laya存档的底层怎么实现？



# 讲一下FSM

有限个状态以及在这些状态之间的转移等行为的数学模型

- 状态转换图中的结点对应不同的状态对象
- 每个状态对象通过一个输入字符转换到另一个状态上，或者保持原状态不变。

**怎么实现FSM?**



## FSM的特性和应用场景？

状态属于比较稳定的状态，需要按照key进行切换操作。



# 宠物的表情播放怎么实现？

因为每个动作都有一套表情序。

眼睛换贴图，每一步换贴图操作由动作动画上绑定的事件触发。

**这样做有什么缺点？有没有其他更好据拓展性的实现？**

动作和表情序列绑定在一起播放。

当使用动画过渡的时候，如果绑定的事件靠近动画的末尾，会报错，因为已经进入下一个动画，但是前一个动画的事件还是照常要触发。

另一种实现方式：不通过绑在动作上的事件，而是通过数时间来换表情贴图，这里的时间是每次换贴图之间间隔的时间。

## 怎么换贴图？正常的眼睛怎么处理？

正常的眼睛贴图在第一次生成的时候把眼睛信息对象的引用保存下来，然后换上统一的表情贴图，恢复正常的时候在把正常画好的眼睛引用放上去。



## 什么是目标纹理？

目标纹理是Laya摄像机的**RenderTarget**属性，它将摄像机的视图放置在一个纹理上，该纹理可以被应用到另一个对象。可以用于实现镜子，监控摄像机等效果。

使用了目标纹理的摄像机禁用渲染到屏幕。

## 目标纹理怎么实现的？

```typescript
//渲染到纹理的相机
let renderTargetCamera:Laya.Camera = scene.getchild("renderTargetCamera") as Laya.Camera;
let renderTex = new RenderTexture(512, 512);
//RenderTexture是一种特殊纹理，他是将摄影机成像实时渲染转换为材质使用
//选择渲染目标为纹理
renderTargetCamera.renderTarget = renderTex;
//渲染顺序，在LayaAir引擎中渲染顺序是越小渲染优先度越高。
renderTargetCamera.renderingOrder = -1;
//清除标记
renderTargetCamera.clearFlag = BaseCamera.CLEARFLAG_SKY;
```

将相机渲染的内容作为一张纹理赋予立方体的材质

```typescript
//设置网格精灵的反射率贴图
mat.albedoTexture = renderTargetCamera.renderTarget;
```

## 渲染纹理是怎么实现的？





# 什么是OSS服务器？

对象存储服务器，用来存储游戏版本

## 游戏怎么打包的？

用Laya官方的发布工具，压缩js，json，材质，png图集。

**打包后图集大小占比？Unity资源占比？**

以粘液宠物为例：

字节包10M,

图集2.6M

Unity资源2.6M

Json表+声音1.9M，

逻辑代码340KB，使用到的js类库2.9M（可以使用压缩类库）

## 打包有什么限制？怎么克服限制？

字节不限制大小，ov，小于4M，魅族小于20M。

本地包保留代码和loading包，和经常要调用的unity导出资源。其他从OSS读取。



# 什么是渲染命令缓冲区？

CommandBuffer为渲染命令缓冲区，**保存渲染命令列表**。

当我们将一些渲染指令添加到CommandBuffer（命令流）后，可以实现对渲染流程的控制，将这些指令在我们想要的时机进行执行。

用来拓展LayaAir引擎渲染管线的渲染效果。在实现毛玻璃（玻璃透明模糊感）、轮廓透视描边或者边缘光效、沙滩脚印、景深等等效果

### 使用步骤

1.创建，添加渲染指令

```typescript
var buf:CommandBuffer = new CommandBuffer();
buf.setRenderTarget(renderTexture);
buf.drawRender(renders[i],materials[i],0);
```

2.绑定commandBuffer到Camera的渲染事件中

```typescript
this.camera.addCommandBuffer(this.cameraEventFlag,this.commandBuffer);
```

怎么删除commandBuffer

```typescript
this.camera.removeCommandBuffer(this.cameraEventFlag,this.commandBuffer);
```

```typescript
//laya支持的Camera事件:
BeforeForwardOpaque = 0,//在渲染非透明物体之前
BeforeSkyBox = 2,//在渲染天空盒之前
BeforeTransparent = 4,//在渲染透明物体之
BeforeImageEffect = 6,//在后期处理之前
AfterEveryThing = 8,//所有渲染之后
```

CommandBuffer是一个渲染指令集，组成这个渲染指令集的是一个一个的独立的渲染指令，可以组合不同的渲染指令然后放入不同的渲染流程

```typescript
setShaderData//设置shader数据，可以设置shader中的texture vector number等 
setGlobalShaderData//设置全局数据，可以用于所有的shader
blitScreenQuad//通过全屏四边形将源纹理渲染到目标渲染纹理指令。
blitScreenQuadByMaterial//通过全屏四边形将源纹理渲染到目标渲染纹理指令
setRenderTarget//设置指令渲染目标，调用后，所有的渲染都会渲染到方法绑定的图片上
clearRenderTarget//清理绑定的渲染纹理
drawMesh//渲染一个Mesh
drawRender//渲染一个Render
```



## CommandBuffer的底层？



## Laya.BaseRender的内部实现？



## Laya.BlurEffect的内部实现？



## 描边效果的实现步骤？

重新画物体为轮廓的颜色，再将图片模糊，模糊图片颜色减去没模糊的图片，就能得到渲染边框，最后将渲染边框重新加到渲染好的画布上。

需要BaseRander，BlurEffect，

```typescript
var renders:BaseRender[]  = [];
var materials:Material[] = [];
renders.push((scene.getChildByName("Cube") as MeshSprite3D).meshRenderer);
materials.push(unlitMaterial);
renders.push((scene.getChildByName("Particle") as ShuriKenParticle3D).particleRenderer);
materials.push(shurikenMaterial);   renders.push((scene.getChildByName("LayaMonkey").getChildByName("LayaMonkey") as SkinnedMeshSprite3D).skinnedMeshRenderer);
materials.push(unlitMaterial);

//创建commandBuffer
this.commandBuffer = this.createDrawMeshCommandBuffer(this.camera,renders,materials);
//将commandBuffer加入渲染流程
this.camera.addCommandBuffer(this.cameraEventFlag,this.commandBuffer);

//创建commandBuffer的函数
createDrawMeshCommandBuffer(camera:Camera,renders:BaseRender[],materials:Material[]):CommandBuffer{
		var buf:CommandBuffer = new CommandBuffer();
		//当需要在流程中拿摄像机渲染效果的时候 设置true
		camera.enableBuiltInRenderTexture = true;
		//创建和屏幕一样大的Rendertexture
		var viewPort:Viewport = camera.viewport;
		var renderTexture = RenderTexture.createFromPool(viewPort.width,viewPort.height,RenderTextureFormat.R8G8B8A8,RenderTextureDepthFormat.DEPTHSTENCIL_NONE);
		//将RenderTexture设置为渲染目标
		buf.setRenderTarget(renderTexture);
		//清楚渲染目标的颜色为黑色，不清理深度
		buf.clearRenderTarget(true,false,new Vector4(0,0,0,0));
		
		//将传入的Render渲染到纹理上
		for(var i = 0,n = renders.length;i<n;i++){
			buf.drawRender(renders[i],materials[i],0);
		}
		//创建新的RenderTexture
		 var subRendertexture = RenderTexture.createFromPool(viewPort.width,viewPort.height,RenderTextureFormat.R8G8B8A8,RenderTextureDepthFormat.DEPTHSTENCIL_NONE);
		//将renderTexture的结果复制到subRenderTexture
		 buf.blitScreenQuad(renderTexture,subRendertexture);
		//设置模糊的参数
		 var downSampleFactor:number = 2;
		 var downSampleWidth:number = viewPort.width/downSampleFactor;
		 var downSampleheigh:number = viewPort.height/downSampleFactor;
		var texSize:Vector4 = new Vector4(1.0/viewPort.width,1.0/viewPort.height,viewPort.width,downSampleheigh);
		//创建模糊材质
		var blurMaterial:BlurMaterial = new BlurMaterial(texSize,1);
		
		//创建降采样RenderTexture1
		 var downRenderTexture = RenderTexture.createFromPool(downSampleWidth,downSampleheigh,RenderTextureFormat.R8G8B8,RenderTextureDepthFormat.DEPTHSTENCIL_NONE);
		//降采样  使用blurMaterial材质的0SubShader将Rendertexture渲染到DownRendertexture
		 buf.blitScreenQuadByMaterial(renderTexture,downRenderTexture,null,blurMaterial,0);

		 //创建降采样RenderTexture2
		var blurTexture:RenderTexture = RenderTexture.createFromPool(downSampleWidth,downSampleheigh,RenderTextureFormat.R8G8B8,RenderTextureDepthFormat.DEPTHSTENCIL_NONE);
		blurTexture.filterMode = FilterMode.Bilinear;

		//Horizontal blur 使用blurMaterial材质的1SubShader
		buf.blitScreenQuadByMaterial(downRenderTexture,blurTexture,null,blurMaterial,1);
		//vertical blur	使用blurMaterial材质的2SubShader
		buf.blitScreenQuadByMaterial(blurTexture,downRenderTexture,null,blurMaterial,2);
		//Horizontal blur 使用blurMaterial材质的1SubShader
		buf.blitScreenQuadByMaterial(downRenderTexture,blurTexture,null,blurMaterial,1);
		//vertical blur   使用blurMaterial材质的2SubShader
		buf.blitScreenQuadByMaterial(blurTexture,downRenderTexture,null,blurMaterial,2);
		//在命令流里面插入设置图片命令流，在调用的时候会设置blurMaterial的图片数据
		buf.setShaderDataTexture(blurMaterial._shaderValues,BlurMaterial.SHADERVALUE_SOURCETEXTURE0,downRenderTexture);
		buf.setShaderDataTexture(blurMaterial._shaderValues,BlurMaterial.ShADERVALUE_SOURCETEXTURE1,subRendertexture);
		//caculate edge计算边缘图片
		buf.blitScreenQuadByMaterial(blurTexture,renderTexture,null,blurMaterial,3);
		//重新传入图片
		buf.setShaderDataTexture(blurMaterial._shaderValues,BlurMaterial.SHADERVALUE_SOURCETEXTURE0,renderTexture);
		//将camera渲染结果复制到subRendertexture，使用blurMaterial的4通道shader
		buf.blitScreenQuadByMaterial(null,subRendertexture,null,blurMaterial,4);
		//将subRenderTexture重新赋值到camera的渲染结果上面
		buf.blitScreenQuadByMaterial(subRendertexture,null);
		return buf;
	}
```



# Unity资源导出Laya的底层原理？



## 抖音的录屏功能底层原理？



## Laya怎么实现异步？

