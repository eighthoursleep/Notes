# ACT技能编辑器

要求：支持编辑动作每一帧的攻击受击框，配置按键指令的招式转换，以及各种攻击数据的配置

|      | 编辑器                                                       | excel（xml）                                                 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 优点 | 所见即所得，策划工作效率搞高<br />每次只关注独立一小块的配置<br />方便做配置数据检查，排错 | 程序省事，开发量小                                           |
| 缺点 | 需要开发，维护<br />策划需要学习成本                         | 可见性差，配置逻辑困难<br />数据检查，排错困难<br />策划工作销量低 |

1. 尽可能和新策划搞清楚需求，做Prototype的推演，推演Editor下如何配置，Runtime如何执行。有经验的程序，会花更多的时间在前期的需求整理和逻辑推演上。
2. 和美术梳理工作流程，让美术可以立刻开始做事情，后续能和我们的编辑器很好地对接。所以，在Demo阶段，美术只提供模型Fbx和动画Fbx，剩下由程序整合。

技术选择：

1. Animator的状态机来做逻辑，还是自己做切换逻辑？

|      | Animator状态机                                               | 自己做切换逻辑                                               |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 优点 | 可视化<br />省掉做编辑器的工作<br />功能强大                 | 可定制工作流<br />方便优化和改进<br />根据需求，复杂度最小化 |
| 缺点 | 策划理解配置有难度<br />状态多了，连线复杂<br />不开源，不可控，不好扩展<br />策划的某些需求很难实现 | 需要开发时间                                                 |

选择自己做逻辑切换，核心就是工作流可定制。

Animator状态机自动生成，最简化，不包含任何逻辑和数据。

2. 使用Unity的GUI来做**编辑器**，还是UGUI做？

|      | GUI                                                          | UGUI                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 优点 | 大量插件可用<br />方便直接序列化数据到prefab和ScriptObject<br />不污染runtime代码 | 可见即所得的布局方式<br />可以将整个编辑流程一体化<br />可以和一些runtime代码整合，直接验证runtime效果<br />可以让序列化数据和prefab分离，不污染美术做的prefab |
| 缺点 | 布局需要代码<br />写复杂的编辑器时间可能来不及<br />可能和数据序列化方式冲突 | 同时只能代开一个window                                       |

最终选择用UGUI，主要是怕用GUI时间来不及。

另一个原因是我希望策划能在一个技能编辑器下做所有的操作，流程一体化。不要那种在A Prefab上挂个脚本，再在B Prefab上挂个脚本，最后把A和B拖到C Prefab脚本的Field上这种编辑方式，这不利于策划理顺思路。

3. 如何做编辑器数据的序列化？

|      | ScriptableObject或Prefab挂脚本                               | txt, xml, json, byte等存数据方式                             |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 优点 | 方便简单，原生支持，省力<br />能序列化Unity自己的一些数据类型，例如：Color, Curve等 | 如果用文本，方便版本管理merge<br />数据和资源分离，方便管理<br />数据热更新方便<br />可定制化程度高 |
| 缺点 | 不方便热更新（dll热更新方式下，新加和修改无法热更）<br />挂载脚本方式，会污染原始prefab，需要将数据和美术资源分离（比如美术mesh需要更新，需要重新生成角色prefab，这时候，需要很小心地替换prefab，因为他包含了数据）<br />不利于版本管理，merge | 需要开发时间<br />不方便序列化一些Unity数据，如Color, Curve等 |

最终选择了自己做序列化，最主要的是数据和资源分离，以及热更新。

4. 是使用Unity自带的Collider（物理系统）来做碰撞，还是自己做碰撞检测？

|      | Unity自带的Collider碰撞                                      | 自己做碰撞                                                   |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 优点 | 只要简单开发即可<br />各种形状碰撞支持完善                   | 可控性强，方便做优化和定制<br />可以很方便按照需求做非真实物理效果<br />可以方便地做fixed point |
| 缺点 | 性能不可控<br />逻辑上不方便控制和优化<br />难以处理帧同步需要的fixed point问题（后续做网络才想到） | 实现复杂，时间紧                                             |

横版游戏可按传统的格斗游戏做法，只需要做Box，而且是不需要旋转的Box，自己实现的复杂度大大降低，那肯定自己做更可控。

**选择方案的思路：**

1. 没有方案是对所有项目都合适的，选择适合自己项目类型以及开发周期，人员配置的方案；
2. 要着重考虑数据和资源的分离，热更新。考虑好和美术、策划的衔接工作流程，这些比逻辑本身更重要；
3. 可控性和开源，尽量使用自己熟悉和可控的实现方式，尽量选择开源的插件和工具。

**ACT游戏需要具备：**

1. **快速的操作反馈**，需要玩家衔接好操作，才能输出最大化；
2. **招式衔接的丰富**，不同招式下，不同时刻，不同按键，要切换到不同的招式；
3. **打击反馈的丰富**，被击需要有动作反馈，轻中重，浮空等各种击中方式，被击者需要不同的动作反馈。



## 以数据为基础来搭建框架

**数据组织参考：**

**ActorCfg**：角色数据的根，包含所有角色相关数据

- **ActorAttr**：基础数据，包含资源Prefab ID，移动速度，重力，指令起始招式ID等
- **ActInfos**(多个)：一个动作的信息，对应美术制作的一个动画（Animation）
  - **FrameInfos**(多个)：每一帧的信息，一般包含攻击，被击框的信息（Position，Scale），以及一些复杂逻辑使用的标记；动作游戏，需要给攻击和被击都打上框，没有被击框的帧，就不会被击中。
- **SkillInfos**(多个)：招式信息。每个招式可以由一个或多个动作（ActInfo）组成，并可以选择动作的帧范围，这样最大程度地复用美术动作，并可以由策划自由发挥，组合出新的动画；
  - **BoxInfo**(多个)：不同类型的Box，不同信息。比如攻击，被击，霸体等不同Box的信息不同；
    - **HitInfo**：攻击类Box，击中以后的数据配置；
  - **ChangeCtrl**(多个)：切换招式的数据。比如在帧范围（0~10内）触发了指令（Up），切换到招式xx；
    - **Trigger**(多个)：各种判断条件，条件达成，才会执行ChangeCtrl
  - **SkillCtrl**(多个)：各种技能处理，播放音效，特效，设置速度等等；
    - **Trigger**(多个)：各种判断条件，条件达成，才会执行SkillCtrl

通过这一套技能编辑处理，策划可以配置出丰富的表现效果。只要数据组织好了，同一数据，有不同的表现形式，这也是基础的MVC的适用。

对于习惯使用类似TimeLine编辑方式的，可以用Frameline方式。



## **序列化数据**

**编辑器，最重要的是数据的读写，也就是序列化和反序列化。**

现在放在手边的选择有两个，一种是序列化为文本（XML，JSON），一种是序列化为Bytes。

我最先是序列化为**XML**，因为我认为XML比JSON可读性强一些，刚开始我可以先手动写一个XML数据，Deserialize为对应的Class，等编辑器基本成型以后，再补上Serialize即可。

这样，我只需要设计一个根据Tag反射来自动化处理的方式即可（当时没仔细找，应该此方式有现成方案）。

XML序列化在前期的好处是，编辑器不稳定，数据经常错误报错，可以手动修改XML的数据，方便测试编辑器Bug，以及调试功能。XML还有很好的可读性，以及版本管理方便Merge。
但是当我们编辑器稳定后，XML的劣势就显现了：

1. 序列化反序列化性能差；
2. 这里需要给一些不支持String化的数据做支持（Color，Curve等）；
3. 序列化依赖变量Name，如果我们重构改了变量名（重构名字是常事），数据就丢失了。

选择用**Protobuf**来做序列化，直接解决1和3的问题

对于2的问题，需要做一些处理，将其**Protobuf**化

再结合**Advanced Inspector**插件来使inspector下支持和原来一样的显示。

至此，基本上解决了序列化和反序列化的问题，最后我们将每一个角色数据，序列化，存为一个.Bytes文件。（带来的副作用，即不方便Merge，这里只有策划通过规范提交修改的流程，减少冲突，目前我们遇到很少）

配合AdvancedInspector提供的UDictionary，我们可以方便地做Dictionary的序列化。



## **SkillCtrl 和 Trigger的设计**

在总体设计好之后，新加的技能方面的功能，主要集中在SkillCtrl 和 Trigger的添加。
这里在语义上是：当XXX的时候，执行YYY。 XXX就是Trigger，YYY就是SkillCtrl 。比如策划可以配置：

- 当0~10帧时，播放技能特效；
- 当10~20帧时，并且是击中状态，播放技能特效；
- 当20~30帧时，震动屏幕；
- 当20~30帧时，角色在浮空状态，添加人物残影；

**在设计上，SkillCtrl和Trigger，都是这样：**

1. 定义一个TriggerType
2. 定义Trigger的基类
3. 之后扩展，就是继承基类，加上配置数据，Override isTrigger方法，处理自己的条件逻辑。

SkillCtrl，主要包含一列Trigger，所有的Trigger都为True，就返回True。这里没有设计or的逻辑方式，Trigger之间，都是And的方式。

对应Runtime逻辑，一个SkillCtrl cfg，对应一个Ctrler

扩展的时候，实现对应的Ctrler即可

大部分游戏，需要设置逻辑主循环，在每一个Logic Tick，去检查Trigger，Trigger都为True，执行对应的Ctrler，即可。这里的Logic Tick，即对应编辑器里面的一个帧，同一概念。

**接下来是一些小的点：**

1. 这里有一个小Trick，就是类命名用"_"分隔，前半部分一样，后半部分区分具体实现，可以通过反射来获得Instance类，以免做工厂，或者Switch case。

```c#
ActorSkillCtrlerCfg_Base cfg = U3DUtil.CreateClassByBaseType<ActorSkillCtrlerCfg_Base>(ctrlType);
```

2. 在这样设计的过程中，遇到了一个问题，就是Unity的Inspector。声明是Base Class，但是赋值了Child Class，Unity的Inspector还是显示Base Class 的数据。

   例如我希望在编辑器里点任何一个Ctrler，都显示对应Ctrler类型的数据。

   Unity默认的Inspector，只会显示申明的类型ActorSkillCtrlerCfg_Base，而不会显示对应的特效数据。

   这里解决方案很简单，引入Advanced Inspector即可，插件能自动显示真实Type的数据，这是Advanced Inspector帮助解决的最大的问题。

   **思考：**每一个功能模块，我们要处理好完全不设计和过度设计的平衡，特别是一开始，不要过度设计。花时间理顺需求，尽量找准扩展点，把扩展点处理好，后续就是往上搭积木了。这个过程中，必然经历几次重构和优化，没有一次就做好的设计，重构是程序的核心技能。

## **编辑器和Excel表数据的配合**

当我们开发Demo的时候，尽可能求快。角色的数据，我们就直接在编辑器里配了，比如攻防血，技能每一个Hit的伤害，招式的CD，消耗的SP等，也并未考虑招式升级了，基础伤害提升等，这些也不是编辑器应该关心的逻辑。

当项目正式化之后，我们需要解决的，就是数据，策划是配置在Excel里的，我们需要整合Excel数据和编辑器数据。

对我们来说，比较麻烦的是，我们结算伤害，并不是以一个技能为一个单位，而是以每一个Hit，一个技能，策划可能配置多个AtkBox，一个AtkBox，可能产生多次Hit，但是，我们不可能给每个Hit配置一个伤害，数值策划配置到这么细，他们会崩溃。所以，策划的Excel表，是以技能（招式）为单位，配置一个伤害。

而技能编辑策划，在技能编辑器里，配置每一个Hit，对应这个伤害的百分比

比如这个招式，策划配整体伤害1000，某个Hit这里配置0.4，最终结果就是1000*0.4 = 400。通过这种方式，将数值策划从编辑器中解脱出来，他们无需关心有几个Hit，只需要处理整体效果，技能编辑策划去将所有Hit的系数分割。当然，我们数值计算很复杂，这只是初步基础数值。

**思考：**这里其实是想说，将逻辑和数值分开来，各自关心各自的东西。这样，我们将Prefab（View），逻辑（技能逻辑），数值（Excel配表）都区分开来，按照一定的规则，在Runtime时候结合。

**经验教训：**
1、没有做整体的Undo和Redo功能，因为做Demo的时候，整体只有两周，实际大概一周半做完。没有时间设计整体的Undo，Redo。后续根据策划需求，解决了部分Copy，Paste，以及依靠Advanced Inspector的功能，做到了Inspector部分的Copy，Paste，也算基本不影响策划的使用。但仍然算是一个不足。

2、战斗整体预览，做得不够完整。目前在播放器里，可以在Play 招式的时候，对应播放特效，声音。但是不能所有SkillCtrl整体模拟。 之前想过在Editor里面跑一个简单的Runtime Battle，只包含当前编辑的角色和一个NPC，让编辑和预览能够无缝衔接。但是处理起来，有点麻烦。 现在的做法是在Runtime 的GM菜单中给一个接口，当打开技能编辑器编辑保存以后，将Runtime Cache的配置清空并重新打开战斗，选定的角色就会重新Load 新保存的配置。虽然这个方法不够完美，但也极大提高了策划的速度（以前编辑好一个，需要重新Run游戏，现在可以在游戏中实时更改，再进入战斗就更新），帮助策划提高工作效率，是程序责无旁贷的责任。

- 有些部分设计得不够友好，策划配起来，有点麻烦。例如配置子弹的逻辑，目前做的不够好。
- 我不想做一个大而全的，能通用的编辑器，我只想理顺思路，当我们下次做项目，或者类似东西的时候，能够在现有的基础上，通过裁剪和重构，快速得到一个符合项目需求的编辑器。（所以我的编辑器，不做任何Unity版本兼容）

现有编辑器，可以支持格斗，ACT，ARPG类游戏，如果做MMO和RPG，那就要裁剪到过于复杂的部分，简化即可。如果做点跑酷呢？那要这编辑器就没意义了，一切都要根据自己的项目来，不是越强大越好。

**最后总结：**

- 当我们需要快速出Demo的时候，更应该理顺思路再动手，切忌上来就编码。把可能的难点先测试搞定，之后就顺手了；
- 重构，不要怕重构，在合适的时间，做合适的重构，是我们程序的核心技能；
- 组织好数据，让数据和美术资源分离，不要让美术资源的变化，干扰你处理数据的工作流；
- 帮助策划提升效率，是程序能力的体现；
- 做编辑器，要站在策划的角度，他们是用户，自己要用，才会发现问题，Eating our own dog food.