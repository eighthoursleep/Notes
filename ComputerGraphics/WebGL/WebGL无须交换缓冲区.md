# WebGL中无须交换缓冲区

“交换缓冲区”这个操作在大多数OpenGL实现中都是必要，但是在WebGL中却比较少见。

OpenGL使用两个颜色缓冲区：前台颜色缓冲区、后台颜色缓冲区。

前台颜色缓冲区中的内容将直接显式在屏幕上。

通常，具体绘图操作的对象实际上是后台缓冲区，在绘图操作完成后，交换指针，使前台缓冲区成为后台缓冲区，后台缓冲区成为前台缓冲区，使得绘制完成的内容显示在屏幕上。

如果在前台颜色缓冲区中绘图，屏幕上就会出现一些视觉假象（比如闪烁），因为在你一帧还没绘制完，就会被更新到屏幕上。

为了支持双缓冲区方法，OpenGL提供了切换前台与后台缓冲区的机制。在某些系统中，切换缓冲区是自动的。而在另一些系统中，需在后台缓冲区绘制完成一帧后，显式地调用切换缓冲区的方法，如`glutSwapBuffers()`或者`eglSwapBuffers()`。比如，一个典型的OpenGL程序中自定义的显式函数可能会是这样的：

```c
void display(void){
    //清楚颜色缓冲区和深度缓冲区
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    draw();//绘制
    glutSwapBuffers();//交换颜色
}
```

相比之下，WebGL能够自动将绘制好的内容完美地更新到屏幕上，无须在自己的程序中显式地交换缓冲区。

WebGL程序向缓冲区中绘图时，**浏览器会自动侦测到绘制操作并在屏幕上显式内容**。因此，WebGL中只有一个颜色缓冲区。

**单缓冲区**之所以可行，是因为由JS编写的WebGL程序对于浏览器来说，**只是一次个更新层方法的调用**。

由于**WebGL程序并非独立运行，而是依赖于浏览器的**，所以**当JS执行结束并退出后，浏览器能够对颜色缓冲区进行检查**。如果**内容被修改过，浏览器就会负责将其显式到屏幕上**。